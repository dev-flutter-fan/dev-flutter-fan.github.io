// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.20.3
// source: message.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "hbb";

export enum Chroma {
  I420 = 0,
  I444 = 1,
  UNRECOGNIZED = -1,
}

export function chromaFromJSON(object: any): Chroma {
  switch (object) {
    case 0:
    case "I420":
      return Chroma.I420;
    case 1:
    case "I444":
      return Chroma.I444;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Chroma.UNRECOGNIZED;
  }
}

export function chromaToJSON(object: Chroma): string {
  switch (object) {
    case Chroma.I420:
      return "I420";
    case Chroma.I444:
      return "I444";
    case Chroma.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum KeyboardMode {
  Legacy = 0,
  Map = 1,
  Translate = 2,
  Auto = 3,
  UNRECOGNIZED = -1,
}

export function keyboardModeFromJSON(object: any): KeyboardMode {
  switch (object) {
    case 0:
    case "Legacy":
      return KeyboardMode.Legacy;
    case 1:
    case "Map":
      return KeyboardMode.Map;
    case 2:
    case "Translate":
      return KeyboardMode.Translate;
    case 3:
    case "Auto":
      return KeyboardMode.Auto;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyboardMode.UNRECOGNIZED;
  }
}

export function keyboardModeToJSON(object: KeyboardMode): string {
  switch (object) {
    case KeyboardMode.Legacy:
      return "Legacy";
    case KeyboardMode.Map:
      return "Map";
    case KeyboardMode.Translate:
      return "Translate";
    case KeyboardMode.Auto:
      return "Auto";
    case KeyboardMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ControlKey {
  Unknown = 0,
  Alt = 1,
  Backspace = 2,
  CapsLock = 3,
  Control = 4,
  Delete = 5,
  DownArrow = 6,
  End = 7,
  Escape = 8,
  F1 = 9,
  F10 = 10,
  F11 = 11,
  F12 = 12,
  F2 = 13,
  F3 = 14,
  F4 = 15,
  F5 = 16,
  F6 = 17,
  F7 = 18,
  F8 = 19,
  F9 = 20,
  Home = 21,
  LeftArrow = 22,
  /** Meta - / meta key (also known as "windows"; "super"; and "command") */
  Meta = 23,
  /** Option - / option key on macOS (alt key on Linux and Windows) */
  Option = 24,
  PageDown = 25,
  PageUp = 26,
  Return = 27,
  RightArrow = 28,
  Shift = 29,
  Space = 30,
  Tab = 31,
  UpArrow = 32,
  Numpad0 = 33,
  Numpad1 = 34,
  Numpad2 = 35,
  Numpad3 = 36,
  Numpad4 = 37,
  Numpad5 = 38,
  Numpad6 = 39,
  Numpad7 = 40,
  Numpad8 = 41,
  Numpad9 = 42,
  Cancel = 43,
  Clear = 44,
  /** Menu - deprecated, use Alt instead */
  Menu = 45,
  Pause = 46,
  Kana = 47,
  Hangul = 48,
  Junja = 49,
  Final = 50,
  Hanja = 51,
  Kanji = 52,
  Convert = 53,
  Select = 54,
  Print = 55,
  Execute = 56,
  Snapshot = 57,
  Insert = 58,
  Help = 59,
  Sleep = 60,
  Separator = 61,
  Scroll = 62,
  NumLock = 63,
  RWin = 64,
  Apps = 65,
  Multiply = 66,
  Add = 67,
  Subtract = 68,
  Decimal = 69,
  Divide = 70,
  Equals = 71,
  NumpadEnter = 72,
  RShift = 73,
  RControl = 74,
  RAlt = 75,
  /** VolumeMute - mainly used on mobile devices as controlled side */
  VolumeMute = 76,
  VolumeUp = 77,
  VolumeDown = 78,
  /** Power - mainly used on mobile devices as controlled side */
  Power = 79,
  CtrlAltDel = 100,
  LockScreen = 101,
  UNRECOGNIZED = -1,
}

export function controlKeyFromJSON(object: any): ControlKey {
  switch (object) {
    case 0:
    case "Unknown":
      return ControlKey.Unknown;
    case 1:
    case "Alt":
      return ControlKey.Alt;
    case 2:
    case "Backspace":
      return ControlKey.Backspace;
    case 3:
    case "CapsLock":
      return ControlKey.CapsLock;
    case 4:
    case "Control":
      return ControlKey.Control;
    case 5:
    case "Delete":
      return ControlKey.Delete;
    case 6:
    case "DownArrow":
      return ControlKey.DownArrow;
    case 7:
    case "End":
      return ControlKey.End;
    case 8:
    case "Escape":
      return ControlKey.Escape;
    case 9:
    case "F1":
      return ControlKey.F1;
    case 10:
    case "F10":
      return ControlKey.F10;
    case 11:
    case "F11":
      return ControlKey.F11;
    case 12:
    case "F12":
      return ControlKey.F12;
    case 13:
    case "F2":
      return ControlKey.F2;
    case 14:
    case "F3":
      return ControlKey.F3;
    case 15:
    case "F4":
      return ControlKey.F4;
    case 16:
    case "F5":
      return ControlKey.F5;
    case 17:
    case "F6":
      return ControlKey.F6;
    case 18:
    case "F7":
      return ControlKey.F7;
    case 19:
    case "F8":
      return ControlKey.F8;
    case 20:
    case "F9":
      return ControlKey.F9;
    case 21:
    case "Home":
      return ControlKey.Home;
    case 22:
    case "LeftArrow":
      return ControlKey.LeftArrow;
    case 23:
    case "Meta":
      return ControlKey.Meta;
    case 24:
    case "Option":
      return ControlKey.Option;
    case 25:
    case "PageDown":
      return ControlKey.PageDown;
    case 26:
    case "PageUp":
      return ControlKey.PageUp;
    case 27:
    case "Return":
      return ControlKey.Return;
    case 28:
    case "RightArrow":
      return ControlKey.RightArrow;
    case 29:
    case "Shift":
      return ControlKey.Shift;
    case 30:
    case "Space":
      return ControlKey.Space;
    case 31:
    case "Tab":
      return ControlKey.Tab;
    case 32:
    case "UpArrow":
      return ControlKey.UpArrow;
    case 33:
    case "Numpad0":
      return ControlKey.Numpad0;
    case 34:
    case "Numpad1":
      return ControlKey.Numpad1;
    case 35:
    case "Numpad2":
      return ControlKey.Numpad2;
    case 36:
    case "Numpad3":
      return ControlKey.Numpad3;
    case 37:
    case "Numpad4":
      return ControlKey.Numpad4;
    case 38:
    case "Numpad5":
      return ControlKey.Numpad5;
    case 39:
    case "Numpad6":
      return ControlKey.Numpad6;
    case 40:
    case "Numpad7":
      return ControlKey.Numpad7;
    case 41:
    case "Numpad8":
      return ControlKey.Numpad8;
    case 42:
    case "Numpad9":
      return ControlKey.Numpad9;
    case 43:
    case "Cancel":
      return ControlKey.Cancel;
    case 44:
    case "Clear":
      return ControlKey.Clear;
    case 45:
    case "Menu":
      return ControlKey.Menu;
    case 46:
    case "Pause":
      return ControlKey.Pause;
    case 47:
    case "Kana":
      return ControlKey.Kana;
    case 48:
    case "Hangul":
      return ControlKey.Hangul;
    case 49:
    case "Junja":
      return ControlKey.Junja;
    case 50:
    case "Final":
      return ControlKey.Final;
    case 51:
    case "Hanja":
      return ControlKey.Hanja;
    case 52:
    case "Kanji":
      return ControlKey.Kanji;
    case 53:
    case "Convert":
      return ControlKey.Convert;
    case 54:
    case "Select":
      return ControlKey.Select;
    case 55:
    case "Print":
      return ControlKey.Print;
    case 56:
    case "Execute":
      return ControlKey.Execute;
    case 57:
    case "Snapshot":
      return ControlKey.Snapshot;
    case 58:
    case "Insert":
      return ControlKey.Insert;
    case 59:
    case "Help":
      return ControlKey.Help;
    case 60:
    case "Sleep":
      return ControlKey.Sleep;
    case 61:
    case "Separator":
      return ControlKey.Separator;
    case 62:
    case "Scroll":
      return ControlKey.Scroll;
    case 63:
    case "NumLock":
      return ControlKey.NumLock;
    case 64:
    case "RWin":
      return ControlKey.RWin;
    case 65:
    case "Apps":
      return ControlKey.Apps;
    case 66:
    case "Multiply":
      return ControlKey.Multiply;
    case 67:
    case "Add":
      return ControlKey.Add;
    case 68:
    case "Subtract":
      return ControlKey.Subtract;
    case 69:
    case "Decimal":
      return ControlKey.Decimal;
    case 70:
    case "Divide":
      return ControlKey.Divide;
    case 71:
    case "Equals":
      return ControlKey.Equals;
    case 72:
    case "NumpadEnter":
      return ControlKey.NumpadEnter;
    case 73:
    case "RShift":
      return ControlKey.RShift;
    case 74:
    case "RControl":
      return ControlKey.RControl;
    case 75:
    case "RAlt":
      return ControlKey.RAlt;
    case 76:
    case "VolumeMute":
      return ControlKey.VolumeMute;
    case 77:
    case "VolumeUp":
      return ControlKey.VolumeUp;
    case 78:
    case "VolumeDown":
      return ControlKey.VolumeDown;
    case 79:
    case "Power":
      return ControlKey.Power;
    case 100:
    case "CtrlAltDel":
      return ControlKey.CtrlAltDel;
    case 101:
    case "LockScreen":
      return ControlKey.LockScreen;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlKey.UNRECOGNIZED;
  }
}

export function controlKeyToJSON(object: ControlKey): string {
  switch (object) {
    case ControlKey.Unknown:
      return "Unknown";
    case ControlKey.Alt:
      return "Alt";
    case ControlKey.Backspace:
      return "Backspace";
    case ControlKey.CapsLock:
      return "CapsLock";
    case ControlKey.Control:
      return "Control";
    case ControlKey.Delete:
      return "Delete";
    case ControlKey.DownArrow:
      return "DownArrow";
    case ControlKey.End:
      return "End";
    case ControlKey.Escape:
      return "Escape";
    case ControlKey.F1:
      return "F1";
    case ControlKey.F10:
      return "F10";
    case ControlKey.F11:
      return "F11";
    case ControlKey.F12:
      return "F12";
    case ControlKey.F2:
      return "F2";
    case ControlKey.F3:
      return "F3";
    case ControlKey.F4:
      return "F4";
    case ControlKey.F5:
      return "F5";
    case ControlKey.F6:
      return "F6";
    case ControlKey.F7:
      return "F7";
    case ControlKey.F8:
      return "F8";
    case ControlKey.F9:
      return "F9";
    case ControlKey.Home:
      return "Home";
    case ControlKey.LeftArrow:
      return "LeftArrow";
    case ControlKey.Meta:
      return "Meta";
    case ControlKey.Option:
      return "Option";
    case ControlKey.PageDown:
      return "PageDown";
    case ControlKey.PageUp:
      return "PageUp";
    case ControlKey.Return:
      return "Return";
    case ControlKey.RightArrow:
      return "RightArrow";
    case ControlKey.Shift:
      return "Shift";
    case ControlKey.Space:
      return "Space";
    case ControlKey.Tab:
      return "Tab";
    case ControlKey.UpArrow:
      return "UpArrow";
    case ControlKey.Numpad0:
      return "Numpad0";
    case ControlKey.Numpad1:
      return "Numpad1";
    case ControlKey.Numpad2:
      return "Numpad2";
    case ControlKey.Numpad3:
      return "Numpad3";
    case ControlKey.Numpad4:
      return "Numpad4";
    case ControlKey.Numpad5:
      return "Numpad5";
    case ControlKey.Numpad6:
      return "Numpad6";
    case ControlKey.Numpad7:
      return "Numpad7";
    case ControlKey.Numpad8:
      return "Numpad8";
    case ControlKey.Numpad9:
      return "Numpad9";
    case ControlKey.Cancel:
      return "Cancel";
    case ControlKey.Clear:
      return "Clear";
    case ControlKey.Menu:
      return "Menu";
    case ControlKey.Pause:
      return "Pause";
    case ControlKey.Kana:
      return "Kana";
    case ControlKey.Hangul:
      return "Hangul";
    case ControlKey.Junja:
      return "Junja";
    case ControlKey.Final:
      return "Final";
    case ControlKey.Hanja:
      return "Hanja";
    case ControlKey.Kanji:
      return "Kanji";
    case ControlKey.Convert:
      return "Convert";
    case ControlKey.Select:
      return "Select";
    case ControlKey.Print:
      return "Print";
    case ControlKey.Execute:
      return "Execute";
    case ControlKey.Snapshot:
      return "Snapshot";
    case ControlKey.Insert:
      return "Insert";
    case ControlKey.Help:
      return "Help";
    case ControlKey.Sleep:
      return "Sleep";
    case ControlKey.Separator:
      return "Separator";
    case ControlKey.Scroll:
      return "Scroll";
    case ControlKey.NumLock:
      return "NumLock";
    case ControlKey.RWin:
      return "RWin";
    case ControlKey.Apps:
      return "Apps";
    case ControlKey.Multiply:
      return "Multiply";
    case ControlKey.Add:
      return "Add";
    case ControlKey.Subtract:
      return "Subtract";
    case ControlKey.Decimal:
      return "Decimal";
    case ControlKey.Divide:
      return "Divide";
    case ControlKey.Equals:
      return "Equals";
    case ControlKey.NumpadEnter:
      return "NumpadEnter";
    case ControlKey.RShift:
      return "RShift";
    case ControlKey.RControl:
      return "RControl";
    case ControlKey.RAlt:
      return "RAlt";
    case ControlKey.VolumeMute:
      return "VolumeMute";
    case ControlKey.VolumeUp:
      return "VolumeUp";
    case ControlKey.VolumeDown:
      return "VolumeDown";
    case ControlKey.Power:
      return "Power";
    case ControlKey.CtrlAltDel:
      return "CtrlAltDel";
    case ControlKey.LockScreen:
      return "LockScreen";
    case ControlKey.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ClipboardFormat {
  Text = 0,
  Rtf = 1,
  Html = 2,
  ImageRgba = 21,
  ImagePng = 22,
  ImageSvg = 23,
  Special = 31,
  UNRECOGNIZED = -1,
}

export function clipboardFormatFromJSON(object: any): ClipboardFormat {
  switch (object) {
    case 0:
    case "Text":
      return ClipboardFormat.Text;
    case 1:
    case "Rtf":
      return ClipboardFormat.Rtf;
    case 2:
    case "Html":
      return ClipboardFormat.Html;
    case 21:
    case "ImageRgba":
      return ClipboardFormat.ImageRgba;
    case 22:
    case "ImagePng":
      return ClipboardFormat.ImagePng;
    case 23:
    case "ImageSvg":
      return ClipboardFormat.ImageSvg;
    case 31:
    case "Special":
      return ClipboardFormat.Special;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClipboardFormat.UNRECOGNIZED;
  }
}

export function clipboardFormatToJSON(object: ClipboardFormat): string {
  switch (object) {
    case ClipboardFormat.Text:
      return "Text";
    case ClipboardFormat.Rtf:
      return "Rtf";
    case ClipboardFormat.Html:
      return "Html";
    case ClipboardFormat.ImageRgba:
      return "ImageRgba";
    case ClipboardFormat.ImagePng:
      return "ImagePng";
    case ClipboardFormat.ImageSvg:
      return "ImageSvg";
    case ClipboardFormat.Special:
      return "Special";
    case ClipboardFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FileType {
  Dir = 0,
  DirLink = 2,
  DirDrive = 3,
  File = 4,
  FileLink = 5,
  UNRECOGNIZED = -1,
}

export function fileTypeFromJSON(object: any): FileType {
  switch (object) {
    case 0:
    case "Dir":
      return FileType.Dir;
    case 2:
    case "DirLink":
      return FileType.DirLink;
    case 3:
    case "DirDrive":
      return FileType.DirDrive;
    case 4:
    case "File":
      return FileType.File;
    case 5:
    case "FileLink":
      return FileType.FileLink;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileType.UNRECOGNIZED;
  }
}

export function fileTypeToJSON(object: FileType): string {
  switch (object) {
    case FileType.Dir:
      return "Dir";
    case FileType.DirLink:
      return "DirLink";
    case FileType.DirDrive:
      return "DirDrive";
    case FileType.File:
      return "File";
    case FileType.FileLink:
      return "FileLink";
    case FileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ImageQuality {
  NotSet = 0,
  Low = 2,
  Balanced = 3,
  Best = 4,
  UNRECOGNIZED = -1,
}

export function imageQualityFromJSON(object: any): ImageQuality {
  switch (object) {
    case 0:
    case "NotSet":
      return ImageQuality.NotSet;
    case 2:
    case "Low":
      return ImageQuality.Low;
    case 3:
    case "Balanced":
      return ImageQuality.Balanced;
    case 4:
    case "Best":
      return ImageQuality.Best;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImageQuality.UNRECOGNIZED;
  }
}

export function imageQualityToJSON(object: ImageQuality): string {
  switch (object) {
    case ImageQuality.NotSet:
      return "NotSet";
    case ImageQuality.Low:
      return "Low";
    case ImageQuality.Balanced:
      return "Balanced";
    case ImageQuality.Best:
      return "Best";
    case ImageQuality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EncodedVideoFrame {
  data: Uint8Array;
  key: boolean;
  pts: number;
}

export interface EncodedVideoFrames {
  frames: EncodedVideoFrame[];
}

export interface RGB {
  compress: boolean;
}

/** planes data send directly in binary for better use arraybuffer on web */
export interface YUV {
  compress: boolean;
  stride: number;
}

export interface VideoFrame {
  vp9s?: EncodedVideoFrames | undefined;
  rgb?: RGB | undefined;
  yuv?: YUV | undefined;
  h264s?: EncodedVideoFrames | undefined;
  h265s?: EncodedVideoFrames | undefined;
  vp8s?: EncodedVideoFrames | undefined;
  av1s?: EncodedVideoFrames | undefined;
  display: number;
}

export interface IdPk {
  id: string;
  pk: Uint8Array;
}

export interface DisplayInfo {
  x: number;
  y: number;
  width: number;
  height: number;
  name: string;
  online: boolean;
  cursor_embedded: boolean;
  original_resolution: Resolution | undefined;
  scale: number;
}

export interface PortForward {
  host: string;
  port: number;
}

export interface FileTransfer {
  dir: string;
  show_hidden: boolean;
}

export interface ViewCamera {
}

export interface OSLogin {
  username: string;
  password: string;
}

export interface LoginRequest {
  username: string;
  password: Uint8Array;
  my_id: string;
  my_name: string;
  option: OptionMessage | undefined;
  file_transfer?: FileTransfer | undefined;
  port_forward?: PortForward | undefined;
  view_camera?: ViewCamera | undefined;
  video_ack_required: boolean;
  session_id: number;
  version: string;
  os_login: OSLogin | undefined;
  my_platform: string;
  hwid: Uint8Array;
}

export interface Auth2FA {
  code: string;
  hwid: Uint8Array;
}

export interface ChatMessage {
  text: string;
}

export interface Features {
  privacy_mode: boolean;
}

export interface CodecAbility {
  vp8: boolean;
  vp9: boolean;
  av1: boolean;
  h264: boolean;
  h265: boolean;
}

export interface SupportedEncoding {
  h264: boolean;
  h265: boolean;
  vp8: boolean;
  av1: boolean;
  i444: CodecAbility | undefined;
}

export interface PeerInfo {
  username: string;
  hostname: string;
  platform: string;
  displays: DisplayInfo[];
  current_display: number;
  sas_enabled: boolean;
  version: string;
  features: Features | undefined;
  encoding: SupportedEncoding | undefined;
  resolutions:
    | SupportedResolutions
    | undefined;
  /**
   * Use JSON's key-value format which is friendly for peer to handle.
   * NOTE: Only support one-level dictionaries (for peer to update), and the key is of type string.
   */
  platform_additions: string;
  windows_sessions: WindowsSessions | undefined;
}

export interface WindowsSession {
  sid: number;
  name: string;
}

export interface LoginResponse {
  error?: string | undefined;
  peer_info?: PeerInfo | undefined;
  enable_trusted_devices: boolean;
}

export interface TouchScaleUpdate {
  /**
   * The delta scale factor relative to the previous scale.
   * delta * 1000
   * 0 means scale end
   */
  scale: number;
}

export interface TouchPanStart {
  x: number;
  y: number;
}

export interface TouchPanUpdate {
  /** The delta x position relative to the previous position. */
  x: number;
  /** The delta y position relative to the previous position. */
  y: number;
}

export interface TouchPanEnd {
  x: number;
  y: number;
}

export interface TouchEvent {
  scale_update?: TouchScaleUpdate | undefined;
  pan_start?: TouchPanStart | undefined;
  pan_update?: TouchPanUpdate | undefined;
  pan_end?: TouchPanEnd | undefined;
}

export interface PointerDeviceEvent {
  touch_event?: TouchEvent | undefined;
  modifiers: ControlKey[];
}

export interface MouseEvent {
  mask: number;
  x: number;
  y: number;
  modifiers: ControlKey[];
}

export interface KeyEvent {
  /** `down` indicates the key's state(down or up). */
  down: boolean;
  /** `press` indicates a click event(down and up). */
  press: boolean;
  control_key?:
    | ControlKey
    | undefined;
  /** position key code. win: scancode, linux: key code, macos: key code */
  chr?: number | undefined;
  unicode?: number | undefined;
  seq?:
    | string
    | undefined;
  /**
   * high word. virtual keycode
   * low word. unicode
   */
  win2win_hotkey?: number | undefined;
  modifiers: ControlKey[];
  mode: KeyboardMode;
}

export interface CursorData {
  id: number;
  hotx: number;
  hoty: number;
  width: number;
  height: number;
  colors: Uint8Array;
}

export interface CursorPosition {
  x: number;
  y: number;
}

export interface Hash {
  salt: string;
  challenge: string;
}

export interface Clipboard {
  compress: boolean;
  content: Uint8Array;
  width: number;
  height: number;
  format: ClipboardFormat;
  /** Special format name, only used when format is Special. */
  special_name: string;
}

export interface MultiClipboards {
  clipboards: Clipboard[];
}

export interface FileEntry {
  entry_type: FileType;
  name: string;
  is_hidden: boolean;
  size: number;
  modified_time: number;
}

export interface FileDirectory {
  id: number;
  path: string;
  entries: FileEntry[];
}

export interface ReadDir {
  path: string;
  include_hidden: boolean;
}

export interface ReadEmptyDirs {
  path: string;
  include_hidden: boolean;
}

export interface ReadEmptyDirsResponse {
  path: string;
  empty_dirs: FileDirectory[];
}

export interface ReadAllFiles {
  id: number;
  path: string;
  include_hidden: boolean;
}

export interface FileRename {
  id: number;
  path: string;
  new_name: string;
}

export interface FileAction {
  read_dir?: ReadDir | undefined;
  send?: FileTransferSendRequest | undefined;
  receive?: FileTransferReceiveRequest | undefined;
  create?: FileDirCreate | undefined;
  remove_dir?: FileRemoveDir | undefined;
  remove_file?: FileRemoveFile | undefined;
  all_files?: ReadAllFiles | undefined;
  cancel?: FileTransferCancel | undefined;
  send_confirm?: FileTransferSendConfirmRequest | undefined;
  rename?: FileRename | undefined;
  read_empty_dirs?: ReadEmptyDirs | undefined;
}

export interface FileTransferCancel {
  id: number;
}

export interface FileResponse {
  dir?: FileDirectory | undefined;
  block?: FileTransferBlock | undefined;
  error?: FileTransferError | undefined;
  done?: FileTransferDone | undefined;
  digest?: FileTransferDigest | undefined;
  empty_dirs?: ReadEmptyDirsResponse | undefined;
}

export interface FileTransferDigest {
  id: number;
  file_num: number;
  last_modified: number;
  file_size: number;
  is_upload: boolean;
  is_identical: boolean;
}

export interface FileTransferBlock {
  id: number;
  file_num: number;
  data: Uint8Array;
  compressed: boolean;
  blk_id: number;
}

export interface FileTransferError {
  id: number;
  error: string;
  file_num: number;
}

export interface FileTransferSendRequest {
  id: number;
  path: string;
  include_hidden: boolean;
  file_num: number;
  file_type: FileTransferSendRequest_FileType;
}

export enum FileTransferSendRequest_FileType {
  Generic = 0,
  Printer = 1,
  UNRECOGNIZED = -1,
}

export function fileTransferSendRequest_FileTypeFromJSON(object: any): FileTransferSendRequest_FileType {
  switch (object) {
    case 0:
    case "Generic":
      return FileTransferSendRequest_FileType.Generic;
    case 1:
    case "Printer":
      return FileTransferSendRequest_FileType.Printer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileTransferSendRequest_FileType.UNRECOGNIZED;
  }
}

export function fileTransferSendRequest_FileTypeToJSON(object: FileTransferSendRequest_FileType): string {
  switch (object) {
    case FileTransferSendRequest_FileType.Generic:
      return "Generic";
    case FileTransferSendRequest_FileType.Printer:
      return "Printer";
    case FileTransferSendRequest_FileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FileTransferSendConfirmRequest {
  id: number;
  file_num: number;
  skip?: boolean | undefined;
  offset_blk?: number | undefined;
}

export interface FileTransferDone {
  id: number;
  file_num: number;
}

export interface FileTransferReceiveRequest {
  id: number;
  /** path written to */
  path: string;
  files: FileEntry[];
  file_num: number;
  total_size: number;
}

export interface FileRemoveDir {
  id: number;
  path: string;
  recursive: boolean;
}

export interface FileRemoveFile {
  id: number;
  path: string;
  file_num: number;
}

export interface FileDirCreate {
  id: number;
  path: string;
}

/** main logic from freeRDP */
export interface CliprdrMonitorReady {
}

export interface CliprdrFormat {
  id: number;
  format: string;
}

export interface CliprdrServerFormatList {
  formats: CliprdrFormat[];
}

export interface CliprdrServerFormatListResponse {
  msg_flags: number;
}

export interface CliprdrServerFormatDataRequest {
  requested_format_id: number;
}

export interface CliprdrServerFormatDataResponse {
  msg_flags: number;
  format_data: Uint8Array;
}

export interface CliprdrFileContentsRequest {
  stream_id: number;
  list_index: number;
  dw_flags: number;
  n_position_low: number;
  n_position_high: number;
  cb_requested: number;
  have_clip_data_id: boolean;
  clip_data_id: number;
}

export interface CliprdrFileContentsResponse {
  msg_flags: number;
  stream_id: number;
  requested_data: Uint8Array;
}

/**
 * Try empty clipboard in the following case(Windows only):
 * 1. `A`(Windows) -> `B`, `C`
 * 2. Copy in `A, file clipboards on `B` and `C` are updated.
 * 3. Copy in `B`.
 * `A` should tell `C` to empty the file clipboard.
 */
export interface CliprdrTryEmpty {
}

export interface Cliprdr {
  ready?: CliprdrMonitorReady | undefined;
  format_list?: CliprdrServerFormatList | undefined;
  format_list_response?: CliprdrServerFormatListResponse | undefined;
  format_data_request?: CliprdrServerFormatDataRequest | undefined;
  format_data_response?: CliprdrServerFormatDataResponse | undefined;
  file_contents_request?: CliprdrFileContentsRequest | undefined;
  file_contents_response?: CliprdrFileContentsResponse | undefined;
  try_empty?: CliprdrTryEmpty | undefined;
}

export interface Resolution {
  width: number;
  height: number;
}

export interface DisplayResolution {
  display: number;
  resolution: Resolution | undefined;
}

export interface SupportedResolutions {
  resolutions: Resolution[];
}

export interface SwitchDisplay {
  display: number;
  x: number;
  y: number;
  width: number;
  height: number;
  cursor_embedded: boolean;
  resolutions:
    | SupportedResolutions
    | undefined;
  /** Do not care about the origin point for now. */
  original_resolution: Resolution | undefined;
}

export interface CaptureDisplays {
  add: number[];
  sub: number[];
  set: number[];
}

export interface ToggleVirtualDisplay {
  display: number;
  on: boolean;
}

export interface TogglePrivacyMode {
  impl_key: string;
  on: boolean;
}

export interface PermissionInfo {
  permission: PermissionInfo_Permission;
  enabled: boolean;
}

export enum PermissionInfo_Permission {
  Keyboard = 0,
  Clipboard = 2,
  Audio = 3,
  File = 4,
  Restart = 5,
  Recording = 6,
  BlockInput = 7,
  Camera = 8,
  UNRECOGNIZED = -1,
}

export function permissionInfo_PermissionFromJSON(object: any): PermissionInfo_Permission {
  switch (object) {
    case 0:
    case "Keyboard":
      return PermissionInfo_Permission.Keyboard;
    case 2:
    case "Clipboard":
      return PermissionInfo_Permission.Clipboard;
    case 3:
    case "Audio":
      return PermissionInfo_Permission.Audio;
    case 4:
    case "File":
      return PermissionInfo_Permission.File;
    case 5:
    case "Restart":
      return PermissionInfo_Permission.Restart;
    case 6:
    case "Recording":
      return PermissionInfo_Permission.Recording;
    case 7:
    case "BlockInput":
      return PermissionInfo_Permission.BlockInput;
    case 8:
    case "Camera":
      return PermissionInfo_Permission.Camera;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermissionInfo_Permission.UNRECOGNIZED;
  }
}

export function permissionInfo_PermissionToJSON(object: PermissionInfo_Permission): string {
  switch (object) {
    case PermissionInfo_Permission.Keyboard:
      return "Keyboard";
    case PermissionInfo_Permission.Clipboard:
      return "Clipboard";
    case PermissionInfo_Permission.Audio:
      return "Audio";
    case PermissionInfo_Permission.File:
      return "File";
    case PermissionInfo_Permission.Restart:
      return "Restart";
    case PermissionInfo_Permission.Recording:
      return "Recording";
    case PermissionInfo_Permission.BlockInput:
      return "BlockInput";
    case PermissionInfo_Permission.Camera:
      return "Camera";
    case PermissionInfo_Permission.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SupportedDecoding {
  ability_vp9: number;
  ability_h264: number;
  ability_h265: number;
  prefer: SupportedDecoding_PreferCodec;
  ability_vp8: number;
  ability_av1: number;
  i444: CodecAbility | undefined;
  prefer_chroma: Chroma;
}

export enum SupportedDecoding_PreferCodec {
  Auto = 0,
  VP9 = 1,
  H264 = 2,
  H265 = 3,
  VP8 = 4,
  AV1 = 5,
  UNRECOGNIZED = -1,
}

export function supportedDecoding_PreferCodecFromJSON(object: any): SupportedDecoding_PreferCodec {
  switch (object) {
    case 0:
    case "Auto":
      return SupportedDecoding_PreferCodec.Auto;
    case 1:
    case "VP9":
      return SupportedDecoding_PreferCodec.VP9;
    case 2:
    case "H264":
      return SupportedDecoding_PreferCodec.H264;
    case 3:
    case "H265":
      return SupportedDecoding_PreferCodec.H265;
    case 4:
    case "VP8":
      return SupportedDecoding_PreferCodec.VP8;
    case 5:
    case "AV1":
      return SupportedDecoding_PreferCodec.AV1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SupportedDecoding_PreferCodec.UNRECOGNIZED;
  }
}

export function supportedDecoding_PreferCodecToJSON(object: SupportedDecoding_PreferCodec): string {
  switch (object) {
    case SupportedDecoding_PreferCodec.Auto:
      return "Auto";
    case SupportedDecoding_PreferCodec.VP9:
      return "VP9";
    case SupportedDecoding_PreferCodec.H264:
      return "H264";
    case SupportedDecoding_PreferCodec.H265:
      return "H265";
    case SupportedDecoding_PreferCodec.VP8:
      return "VP8";
    case SupportedDecoding_PreferCodec.AV1:
      return "AV1";
    case SupportedDecoding_PreferCodec.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OptionMessage {
  image_quality: ImageQuality;
  lock_after_session_end: OptionMessage_BoolOption;
  show_remote_cursor: OptionMessage_BoolOption;
  privacy_mode: OptionMessage_BoolOption;
  block_input: OptionMessage_BoolOption;
  custom_image_quality: number;
  disable_audio: OptionMessage_BoolOption;
  disable_clipboard: OptionMessage_BoolOption;
  enable_file_transfer: OptionMessage_BoolOption;
  supported_decoding: SupportedDecoding | undefined;
  custom_fps: number;
  disable_keyboard: OptionMessage_BoolOption;
  /**
   * Position 13 is used for Resolution. Remove later.
   * Resolution custom_resolution = 13;
   * BoolOption support_windows_specific_session = 14;
   * starting from 15 please, do not use removed fields
   */
  follow_remote_cursor: OptionMessage_BoolOption;
  follow_remote_window: OptionMessage_BoolOption;
  disable_camera: OptionMessage_BoolOption;
}

export enum OptionMessage_BoolOption {
  NotSet = 0,
  No = 1,
  Yes = 2,
  UNRECOGNIZED = -1,
}

export function optionMessage_BoolOptionFromJSON(object: any): OptionMessage_BoolOption {
  switch (object) {
    case 0:
    case "NotSet":
      return OptionMessage_BoolOption.NotSet;
    case 1:
    case "No":
      return OptionMessage_BoolOption.No;
    case 2:
    case "Yes":
      return OptionMessage_BoolOption.Yes;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OptionMessage_BoolOption.UNRECOGNIZED;
  }
}

export function optionMessage_BoolOptionToJSON(object: OptionMessage_BoolOption): string {
  switch (object) {
    case OptionMessage_BoolOption.NotSet:
      return "NotSet";
    case OptionMessage_BoolOption.No:
      return "No";
    case OptionMessage_BoolOption.Yes:
      return "Yes";
    case OptionMessage_BoolOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TestDelay {
  time: number;
  from_client: boolean;
  last_delay: number;
  target_bitrate: number;
}

export interface PublicKey {
  asymmetric_value: Uint8Array;
  symmetric_value: Uint8Array;
}

export interface SignedId {
  id: Uint8Array;
}

export interface AudioFormat {
  sample_rate: number;
  channels: number;
}

export interface AudioFrame {
  data: Uint8Array;
}

/** Notify peer to show message box. */
export interface MessageBox {
  /** Message type. Refer to flutter/lib/common.dart/msgBox(). */
  msgtype: string;
  title: string;
  /** English */
  text: string;
  /**
   * If not empty, msgbox provides a button to following the link.
   * The link here can't be directly http url.
   * It must be the key of http url configed in peer side or "rustdesk://*" (jump in app).
   */
  link: string;
}

export interface BackNotification {
  privacy_mode_state?: BackNotification_PrivacyModeState | undefined;
  block_input_state?:
    | BackNotification_BlockInputState
    | undefined;
  /** Supplementary message, for "PrvOnFailed" and "PrvOffFailed" */
  details: string;
  /** The key of the implementation */
  impl_key: string;
}

/** no need to consider block input by someone else */
export enum BackNotification_BlockInputState {
  BlkStateUnknown = 0,
  BlkOnSucceeded = 2,
  BlkOnFailed = 3,
  BlkOffSucceeded = 4,
  BlkOffFailed = 5,
  UNRECOGNIZED = -1,
}

export function backNotification_BlockInputStateFromJSON(object: any): BackNotification_BlockInputState {
  switch (object) {
    case 0:
    case "BlkStateUnknown":
      return BackNotification_BlockInputState.BlkStateUnknown;
    case 2:
    case "BlkOnSucceeded":
      return BackNotification_BlockInputState.BlkOnSucceeded;
    case 3:
    case "BlkOnFailed":
      return BackNotification_BlockInputState.BlkOnFailed;
    case 4:
    case "BlkOffSucceeded":
      return BackNotification_BlockInputState.BlkOffSucceeded;
    case 5:
    case "BlkOffFailed":
      return BackNotification_BlockInputState.BlkOffFailed;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackNotification_BlockInputState.UNRECOGNIZED;
  }
}

export function backNotification_BlockInputStateToJSON(object: BackNotification_BlockInputState): string {
  switch (object) {
    case BackNotification_BlockInputState.BlkStateUnknown:
      return "BlkStateUnknown";
    case BackNotification_BlockInputState.BlkOnSucceeded:
      return "BlkOnSucceeded";
    case BackNotification_BlockInputState.BlkOnFailed:
      return "BlkOnFailed";
    case BackNotification_BlockInputState.BlkOffSucceeded:
      return "BlkOffSucceeded";
    case BackNotification_BlockInputState.BlkOffFailed:
      return "BlkOffFailed";
    case BackNotification_BlockInputState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BackNotification_PrivacyModeState {
  PrvStateUnknown = 0,
  /** PrvOnByOther - Privacy mode on by someone else */
  PrvOnByOther = 2,
  /** PrvNotSupported - Privacy mode is not supported on the remote side */
  PrvNotSupported = 3,
  /** PrvOnSucceeded - Privacy mode on by self */
  PrvOnSucceeded = 4,
  /** PrvOnFailedDenied - Privacy mode on by self, but denied */
  PrvOnFailedDenied = 5,
  /** PrvOnFailedPlugin - Some plugins are not found */
  PrvOnFailedPlugin = 6,
  /** PrvOnFailed - Privacy mode on by self, but failed */
  PrvOnFailed = 7,
  /** PrvOffSucceeded - Privacy mode off by self */
  PrvOffSucceeded = 8,
  /** PrvOffByPeer - Ctrl + P */
  PrvOffByPeer = 9,
  /** PrvOffFailed - Privacy mode off by self, but failed */
  PrvOffFailed = 10,
  PrvOffUnknown = 11,
  UNRECOGNIZED = -1,
}

export function backNotification_PrivacyModeStateFromJSON(object: any): BackNotification_PrivacyModeState {
  switch (object) {
    case 0:
    case "PrvStateUnknown":
      return BackNotification_PrivacyModeState.PrvStateUnknown;
    case 2:
    case "PrvOnByOther":
      return BackNotification_PrivacyModeState.PrvOnByOther;
    case 3:
    case "PrvNotSupported":
      return BackNotification_PrivacyModeState.PrvNotSupported;
    case 4:
    case "PrvOnSucceeded":
      return BackNotification_PrivacyModeState.PrvOnSucceeded;
    case 5:
    case "PrvOnFailedDenied":
      return BackNotification_PrivacyModeState.PrvOnFailedDenied;
    case 6:
    case "PrvOnFailedPlugin":
      return BackNotification_PrivacyModeState.PrvOnFailedPlugin;
    case 7:
    case "PrvOnFailed":
      return BackNotification_PrivacyModeState.PrvOnFailed;
    case 8:
    case "PrvOffSucceeded":
      return BackNotification_PrivacyModeState.PrvOffSucceeded;
    case 9:
    case "PrvOffByPeer":
      return BackNotification_PrivacyModeState.PrvOffByPeer;
    case 10:
    case "PrvOffFailed":
      return BackNotification_PrivacyModeState.PrvOffFailed;
    case 11:
    case "PrvOffUnknown":
      return BackNotification_PrivacyModeState.PrvOffUnknown;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackNotification_PrivacyModeState.UNRECOGNIZED;
  }
}

export function backNotification_PrivacyModeStateToJSON(object: BackNotification_PrivacyModeState): string {
  switch (object) {
    case BackNotification_PrivacyModeState.PrvStateUnknown:
      return "PrvStateUnknown";
    case BackNotification_PrivacyModeState.PrvOnByOther:
      return "PrvOnByOther";
    case BackNotification_PrivacyModeState.PrvNotSupported:
      return "PrvNotSupported";
    case BackNotification_PrivacyModeState.PrvOnSucceeded:
      return "PrvOnSucceeded";
    case BackNotification_PrivacyModeState.PrvOnFailedDenied:
      return "PrvOnFailedDenied";
    case BackNotification_PrivacyModeState.PrvOnFailedPlugin:
      return "PrvOnFailedPlugin";
    case BackNotification_PrivacyModeState.PrvOnFailed:
      return "PrvOnFailed";
    case BackNotification_PrivacyModeState.PrvOffSucceeded:
      return "PrvOffSucceeded";
    case BackNotification_PrivacyModeState.PrvOffByPeer:
      return "PrvOffByPeer";
    case BackNotification_PrivacyModeState.PrvOffFailed:
      return "PrvOffFailed";
    case BackNotification_PrivacyModeState.PrvOffUnknown:
      return "PrvOffUnknown";
    case BackNotification_PrivacyModeState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ElevationRequestWithLogon {
  username: string;
  password: string;
}

export interface ElevationRequest {
  direct?: boolean | undefined;
  logon?: ElevationRequestWithLogon | undefined;
}

export interface SwitchSidesRequest {
  uuid: Uint8Array;
}

export interface SwitchSidesResponse {
  uuid: Uint8Array;
  lr: LoginRequest | undefined;
}

export interface SwitchBack {
}

export interface PluginRequest {
  id: string;
  content: Uint8Array;
}

export interface PluginFailure {
  id: string;
  name: string;
  msg: string;
}

export interface WindowsSessions {
  sessions: WindowsSession[];
  current_sid: number;
}

/** Query messages from peer. */
export interface MessageQuery {
  /**
   * The SwitchDisplay message of the target display.
   * If the target display is not found, the message will be ignored.
   */
  switch_display: number;
}

export interface Misc {
  chat_message?: ChatMessage | undefined;
  switch_display?: SwitchDisplay | undefined;
  permission_info?: PermissionInfo | undefined;
  option?: OptionMessage | undefined;
  audio_format?: AudioFormat | undefined;
  close_reason?: string | undefined;
  refresh_video?: boolean | undefined;
  video_received?: boolean | undefined;
  back_notification?: BackNotification | undefined;
  restart_remote_device?: boolean | undefined;
  uac?: boolean | undefined;
  foreground_window_elevated?: boolean | undefined;
  stop_service?: boolean | undefined;
  elevation_request?: ElevationRequest | undefined;
  elevation_response?: string | undefined;
  portable_service_running?: boolean | undefined;
  switch_sides_request?: SwitchSidesRequest | undefined;
  switch_back?:
    | SwitchBack
    | undefined;
  /**
   * Deprecated since 1.2.4, use `change_display_resolution` (36) instead.
   * But we must keep it for compatibility when peer version < 1.2.4.
   */
  change_resolution?: Resolution | undefined;
  plugin_request?: PluginRequest | undefined;
  plugin_failure?:
    | PluginFailure
    | undefined;
  /** deprecated */
  full_speed_fps?: number | undefined;
  auto_adjust_fps?: number | undefined;
  client_record_status?: boolean | undefined;
  capture_displays?: CaptureDisplays | undefined;
  refresh_video_display?: number | undefined;
  toggle_virtual_display?: ToggleVirtualDisplay | undefined;
  toggle_privacy_mode?: TogglePrivacyMode | undefined;
  supported_encoding?: SupportedEncoding | undefined;
  selected_sid?: number | undefined;
  change_display_resolution?: DisplayResolution | undefined;
  message_query?: MessageQuery | undefined;
  follow_current_display?: number | undefined;
}

export interface VoiceCallRequest {
  req_timestamp: number;
  /** Indicates whether the request is a connect action or a disconnect action. */
  is_connect: boolean;
}

export interface VoiceCallResponse {
  accepted: boolean;
  /** Should copy from [VoiceCallRequest::req_timestamp]. */
  req_timestamp: number;
  ack_timestamp: number;
}

export interface ScreenshotRequest {
  display: number;
  /**
   * sid is the session id on the controlling side
   * It is used to forward the message to the correct remote (session) window.
   */
  sid: string;
}

export interface ScreenshotResponse {
  sid: string;
  /** empty if success */
  msg: string;
  data: Uint8Array;
}

export interface Message {
  signed_id?: SignedId | undefined;
  public_key?: PublicKey | undefined;
  test_delay?: TestDelay | undefined;
  video_frame?: VideoFrame | undefined;
  login_request?: LoginRequest | undefined;
  login_response?: LoginResponse | undefined;
  hash?: Hash | undefined;
  mouse_event?: MouseEvent | undefined;
  audio_frame?: AudioFrame | undefined;
  cursor_data?: CursorData | undefined;
  cursor_position?: CursorPosition | undefined;
  cursor_id?: number | undefined;
  key_event?: KeyEvent | undefined;
  clipboard?: Clipboard | undefined;
  file_action?: FileAction | undefined;
  file_response?: FileResponse | undefined;
  misc?: Misc | undefined;
  cliprdr?: Cliprdr | undefined;
  message_box?: MessageBox | undefined;
  switch_sides_response?: SwitchSidesResponse | undefined;
  voice_call_request?: VoiceCallRequest | undefined;
  voice_call_response?: VoiceCallResponse | undefined;
  peer_info?: PeerInfo | undefined;
  pointer_device_event?: PointerDeviceEvent | undefined;
  auth_2fa?: Auth2FA | undefined;
  multi_clipboards?: MultiClipboards | undefined;
  screenshot_request?: ScreenshotRequest | undefined;
  screenshot_response?: ScreenshotResponse | undefined;
}

function createBaseEncodedVideoFrame(): EncodedVideoFrame {
  return { data: new Uint8Array(0), key: false, pts: 0 };
}

export const EncodedVideoFrame = {
  encode(message: EncodedVideoFrame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.key !== false) {
      writer.uint32(16).bool(message.key);
    }
    if (message.pts !== 0) {
      writer.uint32(24).int64(message.pts);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncodedVideoFrame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncodedVideoFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.key = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pts = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncodedVideoFrame {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      key: isSet(object.key) ? globalThis.Boolean(object.key) : false,
      pts: isSet(object.pts) ? globalThis.Number(object.pts) : 0,
    };
  },

  toJSON(message: EncodedVideoFrame): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.key !== false) {
      obj.key = message.key;
    }
    if (message.pts !== 0) {
      obj.pts = Math.round(message.pts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncodedVideoFrame>, I>>(base?: I): EncodedVideoFrame {
    return EncodedVideoFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncodedVideoFrame>, I>>(object: I): EncodedVideoFrame {
    const message = createBaseEncodedVideoFrame();
    message.data = object.data ?? new Uint8Array(0);
    message.key = object.key ?? false;
    message.pts = object.pts ?? 0;
    return message;
  },
};

function createBaseEncodedVideoFrames(): EncodedVideoFrames {
  return { frames: [] };
}

export const EncodedVideoFrames = {
  encode(message: EncodedVideoFrames, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.frames) {
      EncodedVideoFrame.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncodedVideoFrames {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncodedVideoFrames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frames.push(EncodedVideoFrame.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncodedVideoFrames {
    return {
      frames: globalThis.Array.isArray(object?.frames)
        ? object.frames.map((e: any) => EncodedVideoFrame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EncodedVideoFrames): unknown {
    const obj: any = {};
    if (message.frames?.length) {
      obj.frames = message.frames.map((e) => EncodedVideoFrame.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncodedVideoFrames>, I>>(base?: I): EncodedVideoFrames {
    return EncodedVideoFrames.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncodedVideoFrames>, I>>(object: I): EncodedVideoFrames {
    const message = createBaseEncodedVideoFrames();
    message.frames = object.frames?.map((e) => EncodedVideoFrame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRGB(): RGB {
  return { compress: false };
}

export const RGB = {
  encode(message: RGB, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.compress !== false) {
      writer.uint32(8).bool(message.compress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RGB {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRGB();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.compress = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RGB {
    return { compress: isSet(object.compress) ? globalThis.Boolean(object.compress) : false };
  },

  toJSON(message: RGB): unknown {
    const obj: any = {};
    if (message.compress !== false) {
      obj.compress = message.compress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RGB>, I>>(base?: I): RGB {
    return RGB.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RGB>, I>>(object: I): RGB {
    const message = createBaseRGB();
    message.compress = object.compress ?? false;
    return message;
  },
};

function createBaseYUV(): YUV {
  return { compress: false, stride: 0 };
}

export const YUV = {
  encode(message: YUV, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.compress !== false) {
      writer.uint32(8).bool(message.compress);
    }
    if (message.stride !== 0) {
      writer.uint32(16).int32(message.stride);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): YUV {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYUV();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.compress = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stride = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YUV {
    return {
      compress: isSet(object.compress) ? globalThis.Boolean(object.compress) : false,
      stride: isSet(object.stride) ? globalThis.Number(object.stride) : 0,
    };
  },

  toJSON(message: YUV): unknown {
    const obj: any = {};
    if (message.compress !== false) {
      obj.compress = message.compress;
    }
    if (message.stride !== 0) {
      obj.stride = Math.round(message.stride);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YUV>, I>>(base?: I): YUV {
    return YUV.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YUV>, I>>(object: I): YUV {
    const message = createBaseYUV();
    message.compress = object.compress ?? false;
    message.stride = object.stride ?? 0;
    return message;
  },
};

function createBaseVideoFrame(): VideoFrame {
  return {
    vp9s: undefined,
    rgb: undefined,
    yuv: undefined,
    h264s: undefined,
    h265s: undefined,
    vp8s: undefined,
    av1s: undefined,
    display: 0,
  };
}

export const VideoFrame = {
  encode(message: VideoFrame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vp9s !== undefined) {
      EncodedVideoFrames.encode(message.vp9s, writer.uint32(50).fork()).ldelim();
    }
    if (message.rgb !== undefined) {
      RGB.encode(message.rgb, writer.uint32(58).fork()).ldelim();
    }
    if (message.yuv !== undefined) {
      YUV.encode(message.yuv, writer.uint32(66).fork()).ldelim();
    }
    if (message.h264s !== undefined) {
      EncodedVideoFrames.encode(message.h264s, writer.uint32(82).fork()).ldelim();
    }
    if (message.h265s !== undefined) {
      EncodedVideoFrames.encode(message.h265s, writer.uint32(90).fork()).ldelim();
    }
    if (message.vp8s !== undefined) {
      EncodedVideoFrames.encode(message.vp8s, writer.uint32(98).fork()).ldelim();
    }
    if (message.av1s !== undefined) {
      EncodedVideoFrames.encode(message.av1s, writer.uint32(106).fork()).ldelim();
    }
    if (message.display !== 0) {
      writer.uint32(112).int32(message.display);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VideoFrame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vp9s = EncodedVideoFrames.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rgb = RGB.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.yuv = YUV.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.h264s = EncodedVideoFrames.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.h265s = EncodedVideoFrames.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.vp8s = EncodedVideoFrames.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.av1s = EncodedVideoFrames.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.display = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoFrame {
    return {
      vp9s: isSet(object.vp9s) ? EncodedVideoFrames.fromJSON(object.vp9s) : undefined,
      rgb: isSet(object.rgb) ? RGB.fromJSON(object.rgb) : undefined,
      yuv: isSet(object.yuv) ? YUV.fromJSON(object.yuv) : undefined,
      h264s: isSet(object.h264s) ? EncodedVideoFrames.fromJSON(object.h264s) : undefined,
      h265s: isSet(object.h265s) ? EncodedVideoFrames.fromJSON(object.h265s) : undefined,
      vp8s: isSet(object.vp8s) ? EncodedVideoFrames.fromJSON(object.vp8s) : undefined,
      av1s: isSet(object.av1s) ? EncodedVideoFrames.fromJSON(object.av1s) : undefined,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: VideoFrame): unknown {
    const obj: any = {};
    if (message.vp9s !== undefined) {
      obj.vp9s = EncodedVideoFrames.toJSON(message.vp9s);
    }
    if (message.rgb !== undefined) {
      obj.rgb = RGB.toJSON(message.rgb);
    }
    if (message.yuv !== undefined) {
      obj.yuv = YUV.toJSON(message.yuv);
    }
    if (message.h264s !== undefined) {
      obj.h264s = EncodedVideoFrames.toJSON(message.h264s);
    }
    if (message.h265s !== undefined) {
      obj.h265s = EncodedVideoFrames.toJSON(message.h265s);
    }
    if (message.vp8s !== undefined) {
      obj.vp8s = EncodedVideoFrames.toJSON(message.vp8s);
    }
    if (message.av1s !== undefined) {
      obj.av1s = EncodedVideoFrames.toJSON(message.av1s);
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoFrame>, I>>(base?: I): VideoFrame {
    return VideoFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoFrame>, I>>(object: I): VideoFrame {
    const message = createBaseVideoFrame();
    message.vp9s = (object.vp9s !== undefined && object.vp9s !== null)
      ? EncodedVideoFrames.fromPartial(object.vp9s)
      : undefined;
    message.rgb = (object.rgb !== undefined && object.rgb !== null) ? RGB.fromPartial(object.rgb) : undefined;
    message.yuv = (object.yuv !== undefined && object.yuv !== null) ? YUV.fromPartial(object.yuv) : undefined;
    message.h264s = (object.h264s !== undefined && object.h264s !== null)
      ? EncodedVideoFrames.fromPartial(object.h264s)
      : undefined;
    message.h265s = (object.h265s !== undefined && object.h265s !== null)
      ? EncodedVideoFrames.fromPartial(object.h265s)
      : undefined;
    message.vp8s = (object.vp8s !== undefined && object.vp8s !== null)
      ? EncodedVideoFrames.fromPartial(object.vp8s)
      : undefined;
    message.av1s = (object.av1s !== undefined && object.av1s !== null)
      ? EncodedVideoFrames.fromPartial(object.av1s)
      : undefined;
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseIdPk(): IdPk {
  return { id: "", pk: new Uint8Array(0) };
}

export const IdPk = {
  encode(message: IdPk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pk.length !== 0) {
      writer.uint32(18).bytes(message.pk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IdPk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdPk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pk = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdPk {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(0),
    };
  },

  toJSON(message: IdPk): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pk.length !== 0) {
      obj.pk = base64FromBytes(message.pk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdPk>, I>>(base?: I): IdPk {
    return IdPk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdPk>, I>>(object: I): IdPk {
    const message = createBaseIdPk();
    message.id = object.id ?? "";
    message.pk = object.pk ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDisplayInfo(): DisplayInfo {
  return {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    name: "",
    online: false,
    cursor_embedded: false,
    original_resolution: undefined,
    scale: 0,
  };
}

export const DisplayInfo = {
  encode(message: DisplayInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).sint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).sint32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.online !== false) {
      writer.uint32(48).bool(message.online);
    }
    if (message.cursor_embedded !== false) {
      writer.uint32(56).bool(message.cursor_embedded);
    }
    if (message.original_resolution !== undefined) {
      Resolution.encode(message.original_resolution, writer.uint32(66).fork()).ldelim();
    }
    if (message.scale !== 0) {
      writer.uint32(73).double(message.scale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisplayInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.sint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.online = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cursor_embedded = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.original_resolution = Resolution.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.scale = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayInfo {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      online: isSet(object.online) ? globalThis.Boolean(object.online) : false,
      cursor_embedded: isSet(object.cursor_embedded) ? globalThis.Boolean(object.cursor_embedded) : false,
      original_resolution: isSet(object.original_resolution)
        ? Resolution.fromJSON(object.original_resolution)
        : undefined,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
    };
  },

  toJSON(message: DisplayInfo): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.online !== false) {
      obj.online = message.online;
    }
    if (message.cursor_embedded !== false) {
      obj.cursor_embedded = message.cursor_embedded;
    }
    if (message.original_resolution !== undefined) {
      obj.original_resolution = Resolution.toJSON(message.original_resolution);
    }
    if (message.scale !== 0) {
      obj.scale = message.scale;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayInfo>, I>>(base?: I): DisplayInfo {
    return DisplayInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayInfo>, I>>(object: I): DisplayInfo {
    const message = createBaseDisplayInfo();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.name = object.name ?? "";
    message.online = object.online ?? false;
    message.cursor_embedded = object.cursor_embedded ?? false;
    message.original_resolution = (object.original_resolution !== undefined && object.original_resolution !== null)
      ? Resolution.fromPartial(object.original_resolution)
      : undefined;
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBasePortForward(): PortForward {
  return { host: "", port: 0 };
}

export const PortForward = {
  encode(message: PortForward, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortForward {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortForward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortForward {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: PortForward): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortForward>, I>>(base?: I): PortForward {
    return PortForward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortForward>, I>>(object: I): PortForward {
    const message = createBasePortForward();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseFileTransfer(): FileTransfer {
  return { dir: "", show_hidden: false };
}

export const FileTransfer = {
  encode(message: FileTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dir !== "") {
      writer.uint32(10).string(message.dir);
    }
    if (message.show_hidden !== false) {
      writer.uint32(16).bool(message.show_hidden);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dir = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.show_hidden = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransfer {
    return {
      dir: isSet(object.dir) ? globalThis.String(object.dir) : "",
      show_hidden: isSet(object.show_hidden) ? globalThis.Boolean(object.show_hidden) : false,
    };
  },

  toJSON(message: FileTransfer): unknown {
    const obj: any = {};
    if (message.dir !== "") {
      obj.dir = message.dir;
    }
    if (message.show_hidden !== false) {
      obj.show_hidden = message.show_hidden;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransfer>, I>>(base?: I): FileTransfer {
    return FileTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransfer>, I>>(object: I): FileTransfer {
    const message = createBaseFileTransfer();
    message.dir = object.dir ?? "";
    message.show_hidden = object.show_hidden ?? false;
    return message;
  },
};

function createBaseViewCamera(): ViewCamera {
  return {};
}

export const ViewCamera = {
  encode(_: ViewCamera, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ViewCamera {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewCamera();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ViewCamera {
    return {};
  },

  toJSON(_: ViewCamera): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewCamera>, I>>(base?: I): ViewCamera {
    return ViewCamera.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewCamera>, I>>(_: I): ViewCamera {
    const message = createBaseViewCamera();
    return message;
  },
};

function createBaseOSLogin(): OSLogin {
  return { username: "", password: "" };
}

export const OSLogin = {
  encode(message: OSLogin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OSLogin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSLogin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSLogin {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: OSLogin): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OSLogin>, I>>(base?: I): OSLogin {
    return OSLogin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OSLogin>, I>>(object: I): OSLogin {
    const message = createBaseOSLogin();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return {
    username: "",
    password: new Uint8Array(0),
    my_id: "",
    my_name: "",
    option: undefined,
    file_transfer: undefined,
    port_forward: undefined,
    view_camera: undefined,
    video_ack_required: false,
    session_id: 0,
    version: "",
    os_login: undefined,
    my_platform: "",
    hwid: new Uint8Array(0),
  };
}

export const LoginRequest = {
  encode(message: LoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password.length !== 0) {
      writer.uint32(18).bytes(message.password);
    }
    if (message.my_id !== "") {
      writer.uint32(34).string(message.my_id);
    }
    if (message.my_name !== "") {
      writer.uint32(42).string(message.my_name);
    }
    if (message.option !== undefined) {
      OptionMessage.encode(message.option, writer.uint32(50).fork()).ldelim();
    }
    if (message.file_transfer !== undefined) {
      FileTransfer.encode(message.file_transfer, writer.uint32(58).fork()).ldelim();
    }
    if (message.port_forward !== undefined) {
      PortForward.encode(message.port_forward, writer.uint32(66).fork()).ldelim();
    }
    if (message.view_camera !== undefined) {
      ViewCamera.encode(message.view_camera, writer.uint32(122).fork()).ldelim();
    }
    if (message.video_ack_required !== false) {
      writer.uint32(72).bool(message.video_ack_required);
    }
    if (message.session_id !== 0) {
      writer.uint32(80).uint64(message.session_id);
    }
    if (message.version !== "") {
      writer.uint32(90).string(message.version);
    }
    if (message.os_login !== undefined) {
      OSLogin.encode(message.os_login, writer.uint32(98).fork()).ldelim();
    }
    if (message.my_platform !== "") {
      writer.uint32(106).string(message.my_platform);
    }
    if (message.hwid.length !== 0) {
      writer.uint32(114).bytes(message.hwid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.my_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.my_name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.option = OptionMessage.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.file_transfer = FileTransfer.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.port_forward = PortForward.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.view_camera = ViewCamera.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.video_ack_required = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.session_id = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.version = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.os_login = OSLogin.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.my_platform = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.hwid = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? bytesFromBase64(object.password) : new Uint8Array(0),
      my_id: isSet(object.my_id) ? globalThis.String(object.my_id) : "",
      my_name: isSet(object.my_name) ? globalThis.String(object.my_name) : "",
      option: isSet(object.option) ? OptionMessage.fromJSON(object.option) : undefined,
      file_transfer: isSet(object.file_transfer) ? FileTransfer.fromJSON(object.file_transfer) : undefined,
      port_forward: isSet(object.port_forward) ? PortForward.fromJSON(object.port_forward) : undefined,
      view_camera: isSet(object.view_camera) ? ViewCamera.fromJSON(object.view_camera) : undefined,
      video_ack_required: isSet(object.video_ack_required) ? globalThis.Boolean(object.video_ack_required) : false,
      session_id: isSet(object.session_id) ? globalThis.Number(object.session_id) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      os_login: isSet(object.os_login) ? OSLogin.fromJSON(object.os_login) : undefined,
      my_platform: isSet(object.my_platform) ? globalThis.String(object.my_platform) : "",
      hwid: isSet(object.hwid) ? bytesFromBase64(object.hwid) : new Uint8Array(0),
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password.length !== 0) {
      obj.password = base64FromBytes(message.password);
    }
    if (message.my_id !== "") {
      obj.my_id = message.my_id;
    }
    if (message.my_name !== "") {
      obj.my_name = message.my_name;
    }
    if (message.option !== undefined) {
      obj.option = OptionMessage.toJSON(message.option);
    }
    if (message.file_transfer !== undefined) {
      obj.file_transfer = FileTransfer.toJSON(message.file_transfer);
    }
    if (message.port_forward !== undefined) {
      obj.port_forward = PortForward.toJSON(message.port_forward);
    }
    if (message.view_camera !== undefined) {
      obj.view_camera = ViewCamera.toJSON(message.view_camera);
    }
    if (message.video_ack_required !== false) {
      obj.video_ack_required = message.video_ack_required;
    }
    if (message.session_id !== 0) {
      obj.session_id = Math.round(message.session_id);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.os_login !== undefined) {
      obj.os_login = OSLogin.toJSON(message.os_login);
    }
    if (message.my_platform !== "") {
      obj.my_platform = message.my_platform;
    }
    if (message.hwid.length !== 0) {
      obj.hwid = base64FromBytes(message.hwid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? new Uint8Array(0);
    message.my_id = object.my_id ?? "";
    message.my_name = object.my_name ?? "";
    message.option = (object.option !== undefined && object.option !== null)
      ? OptionMessage.fromPartial(object.option)
      : undefined;
    message.file_transfer = (object.file_transfer !== undefined && object.file_transfer !== null)
      ? FileTransfer.fromPartial(object.file_transfer)
      : undefined;
    message.port_forward = (object.port_forward !== undefined && object.port_forward !== null)
      ? PortForward.fromPartial(object.port_forward)
      : undefined;
    message.view_camera = (object.view_camera !== undefined && object.view_camera !== null)
      ? ViewCamera.fromPartial(object.view_camera)
      : undefined;
    message.video_ack_required = object.video_ack_required ?? false;
    message.session_id = object.session_id ?? 0;
    message.version = object.version ?? "";
    message.os_login = (object.os_login !== undefined && object.os_login !== null)
      ? OSLogin.fromPartial(object.os_login)
      : undefined;
    message.my_platform = object.my_platform ?? "";
    message.hwid = object.hwid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuth2FA(): Auth2FA {
  return { code: "", hwid: new Uint8Array(0) };
}

export const Auth2FA = {
  encode(message: Auth2FA, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.hwid.length !== 0) {
      writer.uint32(18).bytes(message.hwid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Auth2FA {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuth2FA();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hwid = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Auth2FA {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      hwid: isSet(object.hwid) ? bytesFromBase64(object.hwid) : new Uint8Array(0),
    };
  },

  toJSON(message: Auth2FA): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.hwid.length !== 0) {
      obj.hwid = base64FromBytes(message.hwid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Auth2FA>, I>>(base?: I): Auth2FA {
    return Auth2FA.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Auth2FA>, I>>(object: I): Auth2FA {
    const message = createBaseAuth2FA();
    message.code = object.code ?? "";
    message.hwid = object.hwid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseChatMessage(): ChatMessage {
  return { text: "" };
}

export const ChatMessage = {
  encode(message: ChatMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseFeatures(): Features {
  return { privacy_mode: false };
}

export const Features = {
  encode(message: Features, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.privacy_mode !== false) {
      writer.uint32(8).bool(message.privacy_mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Features {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.privacy_mode = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Features {
    return { privacy_mode: isSet(object.privacy_mode) ? globalThis.Boolean(object.privacy_mode) : false };
  },

  toJSON(message: Features): unknown {
    const obj: any = {};
    if (message.privacy_mode !== false) {
      obj.privacy_mode = message.privacy_mode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Features>, I>>(base?: I): Features {
    return Features.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Features>, I>>(object: I): Features {
    const message = createBaseFeatures();
    message.privacy_mode = object.privacy_mode ?? false;
    return message;
  },
};

function createBaseCodecAbility(): CodecAbility {
  return { vp8: false, vp9: false, av1: false, h264: false, h265: false };
}

export const CodecAbility = {
  encode(message: CodecAbility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vp8 !== false) {
      writer.uint32(8).bool(message.vp8);
    }
    if (message.vp9 !== false) {
      writer.uint32(16).bool(message.vp9);
    }
    if (message.av1 !== false) {
      writer.uint32(24).bool(message.av1);
    }
    if (message.h264 !== false) {
      writer.uint32(32).bool(message.h264);
    }
    if (message.h265 !== false) {
      writer.uint32(40).bool(message.h265);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CodecAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodecAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.vp8 = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vp9 = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.av1 = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.h264 = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.h265 = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodecAbility {
    return {
      vp8: isSet(object.vp8) ? globalThis.Boolean(object.vp8) : false,
      vp9: isSet(object.vp9) ? globalThis.Boolean(object.vp9) : false,
      av1: isSet(object.av1) ? globalThis.Boolean(object.av1) : false,
      h264: isSet(object.h264) ? globalThis.Boolean(object.h264) : false,
      h265: isSet(object.h265) ? globalThis.Boolean(object.h265) : false,
    };
  },

  toJSON(message: CodecAbility): unknown {
    const obj: any = {};
    if (message.vp8 !== false) {
      obj.vp8 = message.vp8;
    }
    if (message.vp9 !== false) {
      obj.vp9 = message.vp9;
    }
    if (message.av1 !== false) {
      obj.av1 = message.av1;
    }
    if (message.h264 !== false) {
      obj.h264 = message.h264;
    }
    if (message.h265 !== false) {
      obj.h265 = message.h265;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodecAbility>, I>>(base?: I): CodecAbility {
    return CodecAbility.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodecAbility>, I>>(object: I): CodecAbility {
    const message = createBaseCodecAbility();
    message.vp8 = object.vp8 ?? false;
    message.vp9 = object.vp9 ?? false;
    message.av1 = object.av1 ?? false;
    message.h264 = object.h264 ?? false;
    message.h265 = object.h265 ?? false;
    return message;
  },
};

function createBaseSupportedEncoding(): SupportedEncoding {
  return { h264: false, h265: false, vp8: false, av1: false, i444: undefined };
}

export const SupportedEncoding = {
  encode(message: SupportedEncoding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.h264 !== false) {
      writer.uint32(8).bool(message.h264);
    }
    if (message.h265 !== false) {
      writer.uint32(16).bool(message.h265);
    }
    if (message.vp8 !== false) {
      writer.uint32(24).bool(message.vp8);
    }
    if (message.av1 !== false) {
      writer.uint32(32).bool(message.av1);
    }
    if (message.i444 !== undefined) {
      CodecAbility.encode(message.i444, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupportedEncoding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedEncoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.h264 = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.h265 = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.vp8 = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.av1 = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.i444 = CodecAbility.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedEncoding {
    return {
      h264: isSet(object.h264) ? globalThis.Boolean(object.h264) : false,
      h265: isSet(object.h265) ? globalThis.Boolean(object.h265) : false,
      vp8: isSet(object.vp8) ? globalThis.Boolean(object.vp8) : false,
      av1: isSet(object.av1) ? globalThis.Boolean(object.av1) : false,
      i444: isSet(object.i444) ? CodecAbility.fromJSON(object.i444) : undefined,
    };
  },

  toJSON(message: SupportedEncoding): unknown {
    const obj: any = {};
    if (message.h264 !== false) {
      obj.h264 = message.h264;
    }
    if (message.h265 !== false) {
      obj.h265 = message.h265;
    }
    if (message.vp8 !== false) {
      obj.vp8 = message.vp8;
    }
    if (message.av1 !== false) {
      obj.av1 = message.av1;
    }
    if (message.i444 !== undefined) {
      obj.i444 = CodecAbility.toJSON(message.i444);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupportedEncoding>, I>>(base?: I): SupportedEncoding {
    return SupportedEncoding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupportedEncoding>, I>>(object: I): SupportedEncoding {
    const message = createBaseSupportedEncoding();
    message.h264 = object.h264 ?? false;
    message.h265 = object.h265 ?? false;
    message.vp8 = object.vp8 ?? false;
    message.av1 = object.av1 ?? false;
    message.i444 = (object.i444 !== undefined && object.i444 !== null)
      ? CodecAbility.fromPartial(object.i444)
      : undefined;
    return message;
  },
};

function createBasePeerInfo(): PeerInfo {
  return {
    username: "",
    hostname: "",
    platform: "",
    displays: [],
    current_display: 0,
    sas_enabled: false,
    version: "",
    features: undefined,
    encoding: undefined,
    resolutions: undefined,
    platform_additions: "",
    windows_sessions: undefined,
  };
}

export const PeerInfo = {
  encode(message: PeerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    if (message.platform !== "") {
      writer.uint32(26).string(message.platform);
    }
    for (const v of message.displays) {
      DisplayInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.current_display !== 0) {
      writer.uint32(40).int32(message.current_display);
    }
    if (message.sas_enabled !== false) {
      writer.uint32(48).bool(message.sas_enabled);
    }
    if (message.version !== "") {
      writer.uint32(58).string(message.version);
    }
    if (message.features !== undefined) {
      Features.encode(message.features, writer.uint32(74).fork()).ldelim();
    }
    if (message.encoding !== undefined) {
      SupportedEncoding.encode(message.encoding, writer.uint32(82).fork()).ldelim();
    }
    if (message.resolutions !== undefined) {
      SupportedResolutions.encode(message.resolutions, writer.uint32(90).fork()).ldelim();
    }
    if (message.platform_additions !== "") {
      writer.uint32(98).string(message.platform_additions);
    }
    if (message.windows_sessions !== undefined) {
      WindowsSessions.encode(message.windows_sessions, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PeerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displays.push(DisplayInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.current_display = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sas_enabled = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.version = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.features = Features.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.encoding = SupportedEncoding.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.resolutions = SupportedResolutions.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.platform_additions = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.windows_sessions = WindowsSessions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerInfo {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      displays: globalThis.Array.isArray(object?.displays)
        ? object.displays.map((e: any) => DisplayInfo.fromJSON(e))
        : [],
      current_display: isSet(object.current_display) ? globalThis.Number(object.current_display) : 0,
      sas_enabled: isSet(object.sas_enabled) ? globalThis.Boolean(object.sas_enabled) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      features: isSet(object.features) ? Features.fromJSON(object.features) : undefined,
      encoding: isSet(object.encoding) ? SupportedEncoding.fromJSON(object.encoding) : undefined,
      resolutions: isSet(object.resolutions) ? SupportedResolutions.fromJSON(object.resolutions) : undefined,
      platform_additions: isSet(object.platform_additions) ? globalThis.String(object.platform_additions) : "",
      windows_sessions: isSet(object.windows_sessions) ? WindowsSessions.fromJSON(object.windows_sessions) : undefined,
    };
  },

  toJSON(message: PeerInfo): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.displays?.length) {
      obj.displays = message.displays.map((e) => DisplayInfo.toJSON(e));
    }
    if (message.current_display !== 0) {
      obj.current_display = Math.round(message.current_display);
    }
    if (message.sas_enabled !== false) {
      obj.sas_enabled = message.sas_enabled;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.features !== undefined) {
      obj.features = Features.toJSON(message.features);
    }
    if (message.encoding !== undefined) {
      obj.encoding = SupportedEncoding.toJSON(message.encoding);
    }
    if (message.resolutions !== undefined) {
      obj.resolutions = SupportedResolutions.toJSON(message.resolutions);
    }
    if (message.platform_additions !== "") {
      obj.platform_additions = message.platform_additions;
    }
    if (message.windows_sessions !== undefined) {
      obj.windows_sessions = WindowsSessions.toJSON(message.windows_sessions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerInfo>, I>>(base?: I): PeerInfo {
    return PeerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerInfo>, I>>(object: I): PeerInfo {
    const message = createBasePeerInfo();
    message.username = object.username ?? "";
    message.hostname = object.hostname ?? "";
    message.platform = object.platform ?? "";
    message.displays = object.displays?.map((e) => DisplayInfo.fromPartial(e)) || [];
    message.current_display = object.current_display ?? 0;
    message.sas_enabled = object.sas_enabled ?? false;
    message.version = object.version ?? "";
    message.features = (object.features !== undefined && object.features !== null)
      ? Features.fromPartial(object.features)
      : undefined;
    message.encoding = (object.encoding !== undefined && object.encoding !== null)
      ? SupportedEncoding.fromPartial(object.encoding)
      : undefined;
    message.resolutions = (object.resolutions !== undefined && object.resolutions !== null)
      ? SupportedResolutions.fromPartial(object.resolutions)
      : undefined;
    message.platform_additions = object.platform_additions ?? "";
    message.windows_sessions = (object.windows_sessions !== undefined && object.windows_sessions !== null)
      ? WindowsSessions.fromPartial(object.windows_sessions)
      : undefined;
    return message;
  },
};

function createBaseWindowsSession(): WindowsSession {
  return { sid: 0, name: "" };
}

export const WindowsSession = {
  encode(message: WindowsSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sid !== 0) {
      writer.uint32(8).uint32(message.sid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WindowsSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sid = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsSession {
    return {
      sid: isSet(object.sid) ? globalThis.Number(object.sid) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: WindowsSession): unknown {
    const obj: any = {};
    if (message.sid !== 0) {
      obj.sid = Math.round(message.sid);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowsSession>, I>>(base?: I): WindowsSession {
    return WindowsSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowsSession>, I>>(object: I): WindowsSession {
    const message = createBaseWindowsSession();
    message.sid = object.sid ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { error: undefined, peer_info: undefined, enable_trusted_devices: false };
}

export const LoginResponse = {
  encode(message: LoginResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.error !== undefined) {
      writer.uint32(10).string(message.error);
    }
    if (message.peer_info !== undefined) {
      PeerInfo.encode(message.peer_info, writer.uint32(18).fork()).ldelim();
    }
    if (message.enable_trusted_devices !== false) {
      writer.uint32(24).bool(message.enable_trusted_devices);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.peer_info = PeerInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enable_trusted_devices = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      peer_info: isSet(object.peer_info) ? PeerInfo.fromJSON(object.peer_info) : undefined,
      enable_trusted_devices: isSet(object.enable_trusted_devices)
        ? globalThis.Boolean(object.enable_trusted_devices)
        : false,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.peer_info !== undefined) {
      obj.peer_info = PeerInfo.toJSON(message.peer_info);
    }
    if (message.enable_trusted_devices !== false) {
      obj.enable_trusted_devices = message.enable_trusted_devices;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.error = object.error ?? undefined;
    message.peer_info = (object.peer_info !== undefined && object.peer_info !== null)
      ? PeerInfo.fromPartial(object.peer_info)
      : undefined;
    message.enable_trusted_devices = object.enable_trusted_devices ?? false;
    return message;
  },
};

function createBaseTouchScaleUpdate(): TouchScaleUpdate {
  return { scale: 0 };
}

export const TouchScaleUpdate = {
  encode(message: TouchScaleUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.scale !== 0) {
      writer.uint32(8).int32(message.scale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TouchScaleUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchScaleUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scale = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchScaleUpdate {
    return { scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0 };
  },

  toJSON(message: TouchScaleUpdate): unknown {
    const obj: any = {};
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TouchScaleUpdate>, I>>(base?: I): TouchScaleUpdate {
    return TouchScaleUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TouchScaleUpdate>, I>>(object: I): TouchScaleUpdate {
    const message = createBaseTouchScaleUpdate();
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseTouchPanStart(): TouchPanStart {
  return { x: 0, y: 0 };
}

export const TouchPanStart = {
  encode(message: TouchPanStart, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TouchPanStart {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchPanStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchPanStart {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: TouchPanStart): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TouchPanStart>, I>>(base?: I): TouchPanStart {
    return TouchPanStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TouchPanStart>, I>>(object: I): TouchPanStart {
    const message = createBaseTouchPanStart();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseTouchPanUpdate(): TouchPanUpdate {
  return { x: 0, y: 0 };
}

export const TouchPanUpdate = {
  encode(message: TouchPanUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TouchPanUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchPanUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchPanUpdate {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: TouchPanUpdate): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TouchPanUpdate>, I>>(base?: I): TouchPanUpdate {
    return TouchPanUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TouchPanUpdate>, I>>(object: I): TouchPanUpdate {
    const message = createBaseTouchPanUpdate();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseTouchPanEnd(): TouchPanEnd {
  return { x: 0, y: 0 };
}

export const TouchPanEnd = {
  encode(message: TouchPanEnd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TouchPanEnd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchPanEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchPanEnd {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: TouchPanEnd): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TouchPanEnd>, I>>(base?: I): TouchPanEnd {
    return TouchPanEnd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TouchPanEnd>, I>>(object: I): TouchPanEnd {
    const message = createBaseTouchPanEnd();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseTouchEvent(): TouchEvent {
  return { scale_update: undefined, pan_start: undefined, pan_update: undefined, pan_end: undefined };
}

export const TouchEvent = {
  encode(message: TouchEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.scale_update !== undefined) {
      TouchScaleUpdate.encode(message.scale_update, writer.uint32(10).fork()).ldelim();
    }
    if (message.pan_start !== undefined) {
      TouchPanStart.encode(message.pan_start, writer.uint32(18).fork()).ldelim();
    }
    if (message.pan_update !== undefined) {
      TouchPanUpdate.encode(message.pan_update, writer.uint32(26).fork()).ldelim();
    }
    if (message.pan_end !== undefined) {
      TouchPanEnd.encode(message.pan_end, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TouchEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scale_update = TouchScaleUpdate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pan_start = TouchPanStart.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pan_update = TouchPanUpdate.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pan_end = TouchPanEnd.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchEvent {
    return {
      scale_update: isSet(object.scale_update) ? TouchScaleUpdate.fromJSON(object.scale_update) : undefined,
      pan_start: isSet(object.pan_start) ? TouchPanStart.fromJSON(object.pan_start) : undefined,
      pan_update: isSet(object.pan_update) ? TouchPanUpdate.fromJSON(object.pan_update) : undefined,
      pan_end: isSet(object.pan_end) ? TouchPanEnd.fromJSON(object.pan_end) : undefined,
    };
  },

  toJSON(message: TouchEvent): unknown {
    const obj: any = {};
    if (message.scale_update !== undefined) {
      obj.scale_update = TouchScaleUpdate.toJSON(message.scale_update);
    }
    if (message.pan_start !== undefined) {
      obj.pan_start = TouchPanStart.toJSON(message.pan_start);
    }
    if (message.pan_update !== undefined) {
      obj.pan_update = TouchPanUpdate.toJSON(message.pan_update);
    }
    if (message.pan_end !== undefined) {
      obj.pan_end = TouchPanEnd.toJSON(message.pan_end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TouchEvent>, I>>(base?: I): TouchEvent {
    return TouchEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TouchEvent>, I>>(object: I): TouchEvent {
    const message = createBaseTouchEvent();
    message.scale_update = (object.scale_update !== undefined && object.scale_update !== null)
      ? TouchScaleUpdate.fromPartial(object.scale_update)
      : undefined;
    message.pan_start = (object.pan_start !== undefined && object.pan_start !== null)
      ? TouchPanStart.fromPartial(object.pan_start)
      : undefined;
    message.pan_update = (object.pan_update !== undefined && object.pan_update !== null)
      ? TouchPanUpdate.fromPartial(object.pan_update)
      : undefined;
    message.pan_end = (object.pan_end !== undefined && object.pan_end !== null)
      ? TouchPanEnd.fromPartial(object.pan_end)
      : undefined;
    return message;
  },
};

function createBasePointerDeviceEvent(): PointerDeviceEvent {
  return { touch_event: undefined, modifiers: [] };
}

export const PointerDeviceEvent = {
  encode(message: PointerDeviceEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.touch_event !== undefined) {
      TouchEvent.encode(message.touch_event, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.modifiers) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PointerDeviceEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointerDeviceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.touch_event = TouchEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.modifiers.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.modifiers.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointerDeviceEvent {
    return {
      touch_event: isSet(object.touch_event) ? TouchEvent.fromJSON(object.touch_event) : undefined,
      modifiers: globalThis.Array.isArray(object?.modifiers)
        ? object.modifiers.map((e: any) => controlKeyFromJSON(e))
        : [],
    };
  },

  toJSON(message: PointerDeviceEvent): unknown {
    const obj: any = {};
    if (message.touch_event !== undefined) {
      obj.touch_event = TouchEvent.toJSON(message.touch_event);
    }
    if (message.modifiers?.length) {
      obj.modifiers = message.modifiers.map((e) => controlKeyToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointerDeviceEvent>, I>>(base?: I): PointerDeviceEvent {
    return PointerDeviceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointerDeviceEvent>, I>>(object: I): PointerDeviceEvent {
    const message = createBasePointerDeviceEvent();
    message.touch_event = (object.touch_event !== undefined && object.touch_event !== null)
      ? TouchEvent.fromPartial(object.touch_event)
      : undefined;
    message.modifiers = object.modifiers?.map((e) => e) || [];
    return message;
  },
};

function createBaseMouseEvent(): MouseEvent {
  return { mask: 0, x: 0, y: 0, modifiers: [] };
}

export const MouseEvent = {
  encode(message: MouseEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mask !== 0) {
      writer.uint32(8).int32(message.mask);
    }
    if (message.x !== 0) {
      writer.uint32(16).sint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).sint32(message.y);
    }
    writer.uint32(34).fork();
    for (const v of message.modifiers) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MouseEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMouseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mask = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.x = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.y = reader.sint32();
          continue;
        case 4:
          if (tag === 32) {
            message.modifiers.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.modifiers.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MouseEvent {
    return {
      mask: isSet(object.mask) ? globalThis.Number(object.mask) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      modifiers: globalThis.Array.isArray(object?.modifiers)
        ? object.modifiers.map((e: any) => controlKeyFromJSON(e))
        : [],
    };
  },

  toJSON(message: MouseEvent): unknown {
    const obj: any = {};
    if (message.mask !== 0) {
      obj.mask = Math.round(message.mask);
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.modifiers?.length) {
      obj.modifiers = message.modifiers.map((e) => controlKeyToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MouseEvent>, I>>(base?: I): MouseEvent {
    return MouseEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MouseEvent>, I>>(object: I): MouseEvent {
    const message = createBaseMouseEvent();
    message.mask = object.mask ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.modifiers = object.modifiers?.map((e) => e) || [];
    return message;
  },
};

function createBaseKeyEvent(): KeyEvent {
  return {
    down: false,
    press: false,
    control_key: undefined,
    chr: undefined,
    unicode: undefined,
    seq: undefined,
    win2win_hotkey: undefined,
    modifiers: [],
    mode: 0,
  };
}

export const KeyEvent = {
  encode(message: KeyEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.down !== false) {
      writer.uint32(8).bool(message.down);
    }
    if (message.press !== false) {
      writer.uint32(16).bool(message.press);
    }
    if (message.control_key !== undefined) {
      writer.uint32(24).int32(message.control_key);
    }
    if (message.chr !== undefined) {
      writer.uint32(32).uint32(message.chr);
    }
    if (message.unicode !== undefined) {
      writer.uint32(40).uint32(message.unicode);
    }
    if (message.seq !== undefined) {
      writer.uint32(50).string(message.seq);
    }
    if (message.win2win_hotkey !== undefined) {
      writer.uint32(56).uint32(message.win2win_hotkey);
    }
    writer.uint32(66).fork();
    for (const v of message.modifiers) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.mode !== 0) {
      writer.uint32(72).int32(message.mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KeyEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.down = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.press = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.control_key = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.chr = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.unicode = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.seq = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.win2win_hotkey = reader.uint32();
          continue;
        case 8:
          if (tag === 64) {
            message.modifiers.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.modifiers.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyEvent {
    return {
      down: isSet(object.down) ? globalThis.Boolean(object.down) : false,
      press: isSet(object.press) ? globalThis.Boolean(object.press) : false,
      control_key: isSet(object.control_key) ? controlKeyFromJSON(object.control_key) : undefined,
      chr: isSet(object.chr) ? globalThis.Number(object.chr) : undefined,
      unicode: isSet(object.unicode) ? globalThis.Number(object.unicode) : undefined,
      seq: isSet(object.seq) ? globalThis.String(object.seq) : undefined,
      win2win_hotkey: isSet(object.win2win_hotkey) ? globalThis.Number(object.win2win_hotkey) : undefined,
      modifiers: globalThis.Array.isArray(object?.modifiers)
        ? object.modifiers.map((e: any) => controlKeyFromJSON(e))
        : [],
      mode: isSet(object.mode) ? keyboardModeFromJSON(object.mode) : 0,
    };
  },

  toJSON(message: KeyEvent): unknown {
    const obj: any = {};
    if (message.down !== false) {
      obj.down = message.down;
    }
    if (message.press !== false) {
      obj.press = message.press;
    }
    if (message.control_key !== undefined) {
      obj.control_key = controlKeyToJSON(message.control_key);
    }
    if (message.chr !== undefined) {
      obj.chr = Math.round(message.chr);
    }
    if (message.unicode !== undefined) {
      obj.unicode = Math.round(message.unicode);
    }
    if (message.seq !== undefined) {
      obj.seq = message.seq;
    }
    if (message.win2win_hotkey !== undefined) {
      obj.win2win_hotkey = Math.round(message.win2win_hotkey);
    }
    if (message.modifiers?.length) {
      obj.modifiers = message.modifiers.map((e) => controlKeyToJSON(e));
    }
    if (message.mode !== 0) {
      obj.mode = keyboardModeToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyEvent>, I>>(base?: I): KeyEvent {
    return KeyEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyEvent>, I>>(object: I): KeyEvent {
    const message = createBaseKeyEvent();
    message.down = object.down ?? false;
    message.press = object.press ?? false;
    message.control_key = object.control_key ?? undefined;
    message.chr = object.chr ?? undefined;
    message.unicode = object.unicode ?? undefined;
    message.seq = object.seq ?? undefined;
    message.win2win_hotkey = object.win2win_hotkey ?? undefined;
    message.modifiers = object.modifiers?.map((e) => e) || [];
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseCursorData(): CursorData {
  return { id: 0, hotx: 0, hoty: 0, width: 0, height: 0, colors: new Uint8Array(0) };
}

export const CursorData = {
  encode(message: CursorData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.hotx !== 0) {
      writer.uint32(16).sint32(message.hotx);
    }
    if (message.hoty !== 0) {
      writer.uint32(24).sint32(message.hoty);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.colors.length !== 0) {
      writer.uint32(50).bytes(message.colors);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CursorData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursorData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hotx = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hoty = reader.sint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.colors = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CursorData {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      hotx: isSet(object.hotx) ? globalThis.Number(object.hotx) : 0,
      hoty: isSet(object.hoty) ? globalThis.Number(object.hoty) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      colors: isSet(object.colors) ? bytesFromBase64(object.colors) : new Uint8Array(0),
    };
  },

  toJSON(message: CursorData): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.hotx !== 0) {
      obj.hotx = Math.round(message.hotx);
    }
    if (message.hoty !== 0) {
      obj.hoty = Math.round(message.hoty);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.colors.length !== 0) {
      obj.colors = base64FromBytes(message.colors);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CursorData>, I>>(base?: I): CursorData {
    return CursorData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CursorData>, I>>(object: I): CursorData {
    const message = createBaseCursorData();
    message.id = object.id ?? 0;
    message.hotx = object.hotx ?? 0;
    message.hoty = object.hoty ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.colors = object.colors ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCursorPosition(): CursorPosition {
  return { x: 0, y: 0 };
}

export const CursorPosition = {
  encode(message: CursorPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).sint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).sint32(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CursorPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursorPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.sint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CursorPosition {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: CursorPosition): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CursorPosition>, I>>(base?: I): CursorPosition {
    return CursorPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CursorPosition>, I>>(object: I): CursorPosition {
    const message = createBaseCursorPosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseHash(): Hash {
  return { salt: "", challenge: "" };
}

export const Hash = {
  encode(message: Hash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.salt !== "") {
      writer.uint32(10).string(message.salt);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Hash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.salt = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hash {
    return {
      salt: isSet(object.salt) ? globalThis.String(object.salt) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: Hash): unknown {
    const obj: any = {};
    if (message.salt !== "") {
      obj.salt = message.salt;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hash>, I>>(base?: I): Hash {
    return Hash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hash>, I>>(object: I): Hash {
    const message = createBaseHash();
    message.salt = object.salt ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseClipboard(): Clipboard {
  return { compress: false, content: new Uint8Array(0), width: 0, height: 0, format: 0, special_name: "" };
}

export const Clipboard = {
  encode(message: Clipboard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.compress !== false) {
      writer.uint32(8).bool(message.compress);
    }
    if (message.content.length !== 0) {
      writer.uint32(18).bytes(message.content);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.format !== 0) {
      writer.uint32(40).int32(message.format);
    }
    if (message.special_name !== "") {
      writer.uint32(50).string(message.special_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Clipboard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipboard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.compress = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.special_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clipboard {
    return {
      compress: isSet(object.compress) ? globalThis.Boolean(object.compress) : false,
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      format: isSet(object.format) ? clipboardFormatFromJSON(object.format) : 0,
      special_name: isSet(object.special_name) ? globalThis.String(object.special_name) : "",
    };
  },

  toJSON(message: Clipboard): unknown {
    const obj: any = {};
    if (message.compress !== false) {
      obj.compress = message.compress;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.format !== 0) {
      obj.format = clipboardFormatToJSON(message.format);
    }
    if (message.special_name !== "") {
      obj.special_name = message.special_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Clipboard>, I>>(base?: I): Clipboard {
    return Clipboard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Clipboard>, I>>(object: I): Clipboard {
    const message = createBaseClipboard();
    message.compress = object.compress ?? false;
    message.content = object.content ?? new Uint8Array(0);
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.format = object.format ?? 0;
    message.special_name = object.special_name ?? "";
    return message;
  },
};

function createBaseMultiClipboards(): MultiClipboards {
  return { clipboards: [] };
}

export const MultiClipboards = {
  encode(message: MultiClipboards, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.clipboards) {
      Clipboard.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MultiClipboards {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiClipboards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clipboards.push(Clipboard.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiClipboards {
    return {
      clipboards: globalThis.Array.isArray(object?.clipboards)
        ? object.clipboards.map((e: any) => Clipboard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiClipboards): unknown {
    const obj: any = {};
    if (message.clipboards?.length) {
      obj.clipboards = message.clipboards.map((e) => Clipboard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiClipboards>, I>>(base?: I): MultiClipboards {
    return MultiClipboards.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiClipboards>, I>>(object: I): MultiClipboards {
    const message = createBaseMultiClipboards();
    message.clipboards = object.clipboards?.map((e) => Clipboard.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFileEntry(): FileEntry {
  return { entry_type: 0, name: "", is_hidden: false, size: 0, modified_time: 0 };
}

export const FileEntry = {
  encode(message: FileEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entry_type !== 0) {
      writer.uint32(8).int32(message.entry_type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.is_hidden !== false) {
      writer.uint32(24).bool(message.is_hidden);
    }
    if (message.size !== 0) {
      writer.uint32(32).uint64(message.size);
    }
    if (message.modified_time !== 0) {
      writer.uint32(40).uint64(message.modified_time);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entry_type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.is_hidden = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.size = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.modified_time = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileEntry {
    return {
      entry_type: isSet(object.entry_type) ? fileTypeFromJSON(object.entry_type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      is_hidden: isSet(object.is_hidden) ? globalThis.Boolean(object.is_hidden) : false,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      modified_time: isSet(object.modified_time) ? globalThis.Number(object.modified_time) : 0,
    };
  },

  toJSON(message: FileEntry): unknown {
    const obj: any = {};
    if (message.entry_type !== 0) {
      obj.entry_type = fileTypeToJSON(message.entry_type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.is_hidden !== false) {
      obj.is_hidden = message.is_hidden;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.modified_time !== 0) {
      obj.modified_time = Math.round(message.modified_time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileEntry>, I>>(base?: I): FileEntry {
    return FileEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileEntry>, I>>(object: I): FileEntry {
    const message = createBaseFileEntry();
    message.entry_type = object.entry_type ?? 0;
    message.name = object.name ?? "";
    message.is_hidden = object.is_hidden ?? false;
    message.size = object.size ?? 0;
    message.modified_time = object.modified_time ?? 0;
    return message;
  },
};

function createBaseFileDirectory(): FileDirectory {
  return { id: 0, path: "", entries: [] };
}

export const FileDirectory = {
  encode(message: FileDirectory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    for (const v of message.entries) {
      FileEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileDirectory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entries.push(FileEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDirectory {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => FileEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: FileDirectory): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => FileEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileDirectory>, I>>(base?: I): FileDirectory {
    return FileDirectory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileDirectory>, I>>(object: I): FileDirectory {
    const message = createBaseFileDirectory();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.entries = object.entries?.map((e) => FileEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReadDir(): ReadDir {
  return { path: "", include_hidden: false };
}

export const ReadDir = {
  encode(message: ReadDir, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.include_hidden !== false) {
      writer.uint32(16).bool(message.include_hidden);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadDir {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadDir();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.include_hidden = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadDir {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      include_hidden: isSet(object.include_hidden) ? globalThis.Boolean(object.include_hidden) : false,
    };
  },

  toJSON(message: ReadDir): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.include_hidden !== false) {
      obj.include_hidden = message.include_hidden;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadDir>, I>>(base?: I): ReadDir {
    return ReadDir.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadDir>, I>>(object: I): ReadDir {
    const message = createBaseReadDir();
    message.path = object.path ?? "";
    message.include_hidden = object.include_hidden ?? false;
    return message;
  },
};

function createBaseReadEmptyDirs(): ReadEmptyDirs {
  return { path: "", include_hidden: false };
}

export const ReadEmptyDirs = {
  encode(message: ReadEmptyDirs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.include_hidden !== false) {
      writer.uint32(16).bool(message.include_hidden);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadEmptyDirs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadEmptyDirs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.include_hidden = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadEmptyDirs {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      include_hidden: isSet(object.include_hidden) ? globalThis.Boolean(object.include_hidden) : false,
    };
  },

  toJSON(message: ReadEmptyDirs): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.include_hidden !== false) {
      obj.include_hidden = message.include_hidden;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadEmptyDirs>, I>>(base?: I): ReadEmptyDirs {
    return ReadEmptyDirs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadEmptyDirs>, I>>(object: I): ReadEmptyDirs {
    const message = createBaseReadEmptyDirs();
    message.path = object.path ?? "";
    message.include_hidden = object.include_hidden ?? false;
    return message;
  },
};

function createBaseReadEmptyDirsResponse(): ReadEmptyDirsResponse {
  return { path: "", empty_dirs: [] };
}

export const ReadEmptyDirsResponse = {
  encode(message: ReadEmptyDirsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    for (const v of message.empty_dirs) {
      FileDirectory.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadEmptyDirsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadEmptyDirsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.empty_dirs.push(FileDirectory.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadEmptyDirsResponse {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      empty_dirs: globalThis.Array.isArray(object?.empty_dirs)
        ? object.empty_dirs.map((e: any) => FileDirectory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReadEmptyDirsResponse): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.empty_dirs?.length) {
      obj.empty_dirs = message.empty_dirs.map((e) => FileDirectory.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadEmptyDirsResponse>, I>>(base?: I): ReadEmptyDirsResponse {
    return ReadEmptyDirsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadEmptyDirsResponse>, I>>(object: I): ReadEmptyDirsResponse {
    const message = createBaseReadEmptyDirsResponse();
    message.path = object.path ?? "";
    message.empty_dirs = object.empty_dirs?.map((e) => FileDirectory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReadAllFiles(): ReadAllFiles {
  return { id: 0, path: "", include_hidden: false };
}

export const ReadAllFiles = {
  encode(message: ReadAllFiles, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.include_hidden !== false) {
      writer.uint32(24).bool(message.include_hidden);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReadAllFiles {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadAllFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.include_hidden = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadAllFiles {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      include_hidden: isSet(object.include_hidden) ? globalThis.Boolean(object.include_hidden) : false,
    };
  },

  toJSON(message: ReadAllFiles): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.include_hidden !== false) {
      obj.include_hidden = message.include_hidden;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadAllFiles>, I>>(base?: I): ReadAllFiles {
    return ReadAllFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadAllFiles>, I>>(object: I): ReadAllFiles {
    const message = createBaseReadAllFiles();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.include_hidden = object.include_hidden ?? false;
    return message;
  },
};

function createBaseFileRename(): FileRename {
  return { id: 0, path: "", new_name: "" };
}

export const FileRename = {
  encode(message: FileRename, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.new_name !== "") {
      writer.uint32(26).string(message.new_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileRename {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileRename();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.new_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileRename {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      new_name: isSet(object.new_name) ? globalThis.String(object.new_name) : "",
    };
  },

  toJSON(message: FileRename): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.new_name !== "") {
      obj.new_name = message.new_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileRename>, I>>(base?: I): FileRename {
    return FileRename.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileRename>, I>>(object: I): FileRename {
    const message = createBaseFileRename();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.new_name = object.new_name ?? "";
    return message;
  },
};

function createBaseFileAction(): FileAction {
  return {
    read_dir: undefined,
    send: undefined,
    receive: undefined,
    create: undefined,
    remove_dir: undefined,
    remove_file: undefined,
    all_files: undefined,
    cancel: undefined,
    send_confirm: undefined,
    rename: undefined,
    read_empty_dirs: undefined,
  };
}

export const FileAction = {
  encode(message: FileAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.read_dir !== undefined) {
      ReadDir.encode(message.read_dir, writer.uint32(10).fork()).ldelim();
    }
    if (message.send !== undefined) {
      FileTransferSendRequest.encode(message.send, writer.uint32(18).fork()).ldelim();
    }
    if (message.receive !== undefined) {
      FileTransferReceiveRequest.encode(message.receive, writer.uint32(26).fork()).ldelim();
    }
    if (message.create !== undefined) {
      FileDirCreate.encode(message.create, writer.uint32(34).fork()).ldelim();
    }
    if (message.remove_dir !== undefined) {
      FileRemoveDir.encode(message.remove_dir, writer.uint32(42).fork()).ldelim();
    }
    if (message.remove_file !== undefined) {
      FileRemoveFile.encode(message.remove_file, writer.uint32(50).fork()).ldelim();
    }
    if (message.all_files !== undefined) {
      ReadAllFiles.encode(message.all_files, writer.uint32(58).fork()).ldelim();
    }
    if (message.cancel !== undefined) {
      FileTransferCancel.encode(message.cancel, writer.uint32(66).fork()).ldelim();
    }
    if (message.send_confirm !== undefined) {
      FileTransferSendConfirmRequest.encode(message.send_confirm, writer.uint32(74).fork()).ldelim();
    }
    if (message.rename !== undefined) {
      FileRename.encode(message.rename, writer.uint32(82).fork()).ldelim();
    }
    if (message.read_empty_dirs !== undefined) {
      ReadEmptyDirs.encode(message.read_empty_dirs, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.read_dir = ReadDir.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.send = FileTransferSendRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receive = FileTransferReceiveRequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.create = FileDirCreate.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.remove_dir = FileRemoveDir.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.remove_file = FileRemoveFile.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.all_files = ReadAllFiles.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cancel = FileTransferCancel.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.send_confirm = FileTransferSendConfirmRequest.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.rename = FileRename.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.read_empty_dirs = ReadEmptyDirs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileAction {
    return {
      read_dir: isSet(object.read_dir) ? ReadDir.fromJSON(object.read_dir) : undefined,
      send: isSet(object.send) ? FileTransferSendRequest.fromJSON(object.send) : undefined,
      receive: isSet(object.receive) ? FileTransferReceiveRequest.fromJSON(object.receive) : undefined,
      create: isSet(object.create) ? FileDirCreate.fromJSON(object.create) : undefined,
      remove_dir: isSet(object.remove_dir) ? FileRemoveDir.fromJSON(object.remove_dir) : undefined,
      remove_file: isSet(object.remove_file) ? FileRemoveFile.fromJSON(object.remove_file) : undefined,
      all_files: isSet(object.all_files) ? ReadAllFiles.fromJSON(object.all_files) : undefined,
      cancel: isSet(object.cancel) ? FileTransferCancel.fromJSON(object.cancel) : undefined,
      send_confirm: isSet(object.send_confirm)
        ? FileTransferSendConfirmRequest.fromJSON(object.send_confirm)
        : undefined,
      rename: isSet(object.rename) ? FileRename.fromJSON(object.rename) : undefined,
      read_empty_dirs: isSet(object.read_empty_dirs) ? ReadEmptyDirs.fromJSON(object.read_empty_dirs) : undefined,
    };
  },

  toJSON(message: FileAction): unknown {
    const obj: any = {};
    if (message.read_dir !== undefined) {
      obj.read_dir = ReadDir.toJSON(message.read_dir);
    }
    if (message.send !== undefined) {
      obj.send = FileTransferSendRequest.toJSON(message.send);
    }
    if (message.receive !== undefined) {
      obj.receive = FileTransferReceiveRequest.toJSON(message.receive);
    }
    if (message.create !== undefined) {
      obj.create = FileDirCreate.toJSON(message.create);
    }
    if (message.remove_dir !== undefined) {
      obj.remove_dir = FileRemoveDir.toJSON(message.remove_dir);
    }
    if (message.remove_file !== undefined) {
      obj.remove_file = FileRemoveFile.toJSON(message.remove_file);
    }
    if (message.all_files !== undefined) {
      obj.all_files = ReadAllFiles.toJSON(message.all_files);
    }
    if (message.cancel !== undefined) {
      obj.cancel = FileTransferCancel.toJSON(message.cancel);
    }
    if (message.send_confirm !== undefined) {
      obj.send_confirm = FileTransferSendConfirmRequest.toJSON(message.send_confirm);
    }
    if (message.rename !== undefined) {
      obj.rename = FileRename.toJSON(message.rename);
    }
    if (message.read_empty_dirs !== undefined) {
      obj.read_empty_dirs = ReadEmptyDirs.toJSON(message.read_empty_dirs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileAction>, I>>(base?: I): FileAction {
    return FileAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileAction>, I>>(object: I): FileAction {
    const message = createBaseFileAction();
    message.read_dir = (object.read_dir !== undefined && object.read_dir !== null)
      ? ReadDir.fromPartial(object.read_dir)
      : undefined;
    message.send = (object.send !== undefined && object.send !== null)
      ? FileTransferSendRequest.fromPartial(object.send)
      : undefined;
    message.receive = (object.receive !== undefined && object.receive !== null)
      ? FileTransferReceiveRequest.fromPartial(object.receive)
      : undefined;
    message.create = (object.create !== undefined && object.create !== null)
      ? FileDirCreate.fromPartial(object.create)
      : undefined;
    message.remove_dir = (object.remove_dir !== undefined && object.remove_dir !== null)
      ? FileRemoveDir.fromPartial(object.remove_dir)
      : undefined;
    message.remove_file = (object.remove_file !== undefined && object.remove_file !== null)
      ? FileRemoveFile.fromPartial(object.remove_file)
      : undefined;
    message.all_files = (object.all_files !== undefined && object.all_files !== null)
      ? ReadAllFiles.fromPartial(object.all_files)
      : undefined;
    message.cancel = (object.cancel !== undefined && object.cancel !== null)
      ? FileTransferCancel.fromPartial(object.cancel)
      : undefined;
    message.send_confirm = (object.send_confirm !== undefined && object.send_confirm !== null)
      ? FileTransferSendConfirmRequest.fromPartial(object.send_confirm)
      : undefined;
    message.rename = (object.rename !== undefined && object.rename !== null)
      ? FileRename.fromPartial(object.rename)
      : undefined;
    message.read_empty_dirs = (object.read_empty_dirs !== undefined && object.read_empty_dirs !== null)
      ? ReadEmptyDirs.fromPartial(object.read_empty_dirs)
      : undefined;
    return message;
  },
};

function createBaseFileTransferCancel(): FileTransferCancel {
  return { id: 0 };
}

export const FileTransferCancel = {
  encode(message: FileTransferCancel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferCancel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferCancel {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: FileTransferCancel): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferCancel>, I>>(base?: I): FileTransferCancel {
    return FileTransferCancel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferCancel>, I>>(object: I): FileTransferCancel {
    const message = createBaseFileTransferCancel();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseFileResponse(): FileResponse {
  return {
    dir: undefined,
    block: undefined,
    error: undefined,
    done: undefined,
    digest: undefined,
    empty_dirs: undefined,
  };
}

export const FileResponse = {
  encode(message: FileResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dir !== undefined) {
      FileDirectory.encode(message.dir, writer.uint32(10).fork()).ldelim();
    }
    if (message.block !== undefined) {
      FileTransferBlock.encode(message.block, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      FileTransferError.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    if (message.done !== undefined) {
      FileTransferDone.encode(message.done, writer.uint32(34).fork()).ldelim();
    }
    if (message.digest !== undefined) {
      FileTransferDigest.encode(message.digest, writer.uint32(42).fork()).ldelim();
    }
    if (message.empty_dirs !== undefined) {
      ReadEmptyDirsResponse.encode(message.empty_dirs, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dir = FileDirectory.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.block = FileTransferBlock.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = FileTransferError.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.done = FileTransferDone.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.digest = FileTransferDigest.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.empty_dirs = ReadEmptyDirsResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileResponse {
    return {
      dir: isSet(object.dir) ? FileDirectory.fromJSON(object.dir) : undefined,
      block: isSet(object.block) ? FileTransferBlock.fromJSON(object.block) : undefined,
      error: isSet(object.error) ? FileTransferError.fromJSON(object.error) : undefined,
      done: isSet(object.done) ? FileTransferDone.fromJSON(object.done) : undefined,
      digest: isSet(object.digest) ? FileTransferDigest.fromJSON(object.digest) : undefined,
      empty_dirs: isSet(object.empty_dirs) ? ReadEmptyDirsResponse.fromJSON(object.empty_dirs) : undefined,
    };
  },

  toJSON(message: FileResponse): unknown {
    const obj: any = {};
    if (message.dir !== undefined) {
      obj.dir = FileDirectory.toJSON(message.dir);
    }
    if (message.block !== undefined) {
      obj.block = FileTransferBlock.toJSON(message.block);
    }
    if (message.error !== undefined) {
      obj.error = FileTransferError.toJSON(message.error);
    }
    if (message.done !== undefined) {
      obj.done = FileTransferDone.toJSON(message.done);
    }
    if (message.digest !== undefined) {
      obj.digest = FileTransferDigest.toJSON(message.digest);
    }
    if (message.empty_dirs !== undefined) {
      obj.empty_dirs = ReadEmptyDirsResponse.toJSON(message.empty_dirs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileResponse>, I>>(base?: I): FileResponse {
    return FileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileResponse>, I>>(object: I): FileResponse {
    const message = createBaseFileResponse();
    message.dir = (object.dir !== undefined && object.dir !== null) ? FileDirectory.fromPartial(object.dir) : undefined;
    message.block = (object.block !== undefined && object.block !== null)
      ? FileTransferBlock.fromPartial(object.block)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? FileTransferError.fromPartial(object.error)
      : undefined;
    message.done = (object.done !== undefined && object.done !== null)
      ? FileTransferDone.fromPartial(object.done)
      : undefined;
    message.digest = (object.digest !== undefined && object.digest !== null)
      ? FileTransferDigest.fromPartial(object.digest)
      : undefined;
    message.empty_dirs = (object.empty_dirs !== undefined && object.empty_dirs !== null)
      ? ReadEmptyDirsResponse.fromPartial(object.empty_dirs)
      : undefined;
    return message;
  },
};

function createBaseFileTransferDigest(): FileTransferDigest {
  return { id: 0, file_num: 0, last_modified: 0, file_size: 0, is_upload: false, is_identical: false };
}

export const FileTransferDigest = {
  encode(message: FileTransferDigest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.file_num !== 0) {
      writer.uint32(16).sint32(message.file_num);
    }
    if (message.last_modified !== 0) {
      writer.uint32(24).uint64(message.last_modified);
    }
    if (message.file_size !== 0) {
      writer.uint32(32).uint64(message.file_size);
    }
    if (message.is_upload !== false) {
      writer.uint32(40).bool(message.is_upload);
    }
    if (message.is_identical !== false) {
      writer.uint32(48).bool(message.is_identical);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferDigest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferDigest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.file_num = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.last_modified = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.file_size = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_upload = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.is_identical = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferDigest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
      last_modified: isSet(object.last_modified) ? globalThis.Number(object.last_modified) : 0,
      file_size: isSet(object.file_size) ? globalThis.Number(object.file_size) : 0,
      is_upload: isSet(object.is_upload) ? globalThis.Boolean(object.is_upload) : false,
      is_identical: isSet(object.is_identical) ? globalThis.Boolean(object.is_identical) : false,
    };
  },

  toJSON(message: FileTransferDigest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    if (message.last_modified !== 0) {
      obj.last_modified = Math.round(message.last_modified);
    }
    if (message.file_size !== 0) {
      obj.file_size = Math.round(message.file_size);
    }
    if (message.is_upload !== false) {
      obj.is_upload = message.is_upload;
    }
    if (message.is_identical !== false) {
      obj.is_identical = message.is_identical;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferDigest>, I>>(base?: I): FileTransferDigest {
    return FileTransferDigest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferDigest>, I>>(object: I): FileTransferDigest {
    const message = createBaseFileTransferDigest();
    message.id = object.id ?? 0;
    message.file_num = object.file_num ?? 0;
    message.last_modified = object.last_modified ?? 0;
    message.file_size = object.file_size ?? 0;
    message.is_upload = object.is_upload ?? false;
    message.is_identical = object.is_identical ?? false;
    return message;
  },
};

function createBaseFileTransferBlock(): FileTransferBlock {
  return { id: 0, file_num: 0, data: new Uint8Array(0), compressed: false, blk_id: 0 };
}

export const FileTransferBlock = {
  encode(message: FileTransferBlock, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.file_num !== 0) {
      writer.uint32(16).sint32(message.file_num);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.compressed !== false) {
      writer.uint32(32).bool(message.compressed);
    }
    if (message.blk_id !== 0) {
      writer.uint32(40).uint32(message.blk_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferBlock {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.file_num = reader.sint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.compressed = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.blk_id = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferBlock {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      compressed: isSet(object.compressed) ? globalThis.Boolean(object.compressed) : false,
      blk_id: isSet(object.blk_id) ? globalThis.Number(object.blk_id) : 0,
    };
  },

  toJSON(message: FileTransferBlock): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.compressed !== false) {
      obj.compressed = message.compressed;
    }
    if (message.blk_id !== 0) {
      obj.blk_id = Math.round(message.blk_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferBlock>, I>>(base?: I): FileTransferBlock {
    return FileTransferBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferBlock>, I>>(object: I): FileTransferBlock {
    const message = createBaseFileTransferBlock();
    message.id = object.id ?? 0;
    message.file_num = object.file_num ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.compressed = object.compressed ?? false;
    message.blk_id = object.blk_id ?? 0;
    return message;
  },
};

function createBaseFileTransferError(): FileTransferError {
  return { id: 0, error: "", file_num: 0 };
}

export const FileTransferError = {
  encode(message: FileTransferError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.file_num !== 0) {
      writer.uint32(24).sint32(message.file_num);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.file_num = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferError {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
    };
  },

  toJSON(message: FileTransferError): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferError>, I>>(base?: I): FileTransferError {
    return FileTransferError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferError>, I>>(object: I): FileTransferError {
    const message = createBaseFileTransferError();
    message.id = object.id ?? 0;
    message.error = object.error ?? "";
    message.file_num = object.file_num ?? 0;
    return message;
  },
};

function createBaseFileTransferSendRequest(): FileTransferSendRequest {
  return { id: 0, path: "", include_hidden: false, file_num: 0, file_type: 0 };
}

export const FileTransferSendRequest = {
  encode(message: FileTransferSendRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.include_hidden !== false) {
      writer.uint32(24).bool(message.include_hidden);
    }
    if (message.file_num !== 0) {
      writer.uint32(32).int32(message.file_num);
    }
    if (message.file_type !== 0) {
      writer.uint32(40).int32(message.file_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferSendRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferSendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.include_hidden = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.file_num = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.file_type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferSendRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      include_hidden: isSet(object.include_hidden) ? globalThis.Boolean(object.include_hidden) : false,
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
      file_type: isSet(object.file_type) ? fileTransferSendRequest_FileTypeFromJSON(object.file_type) : 0,
    };
  },

  toJSON(message: FileTransferSendRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.include_hidden !== false) {
      obj.include_hidden = message.include_hidden;
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    if (message.file_type !== 0) {
      obj.file_type = fileTransferSendRequest_FileTypeToJSON(message.file_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferSendRequest>, I>>(base?: I): FileTransferSendRequest {
    return FileTransferSendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferSendRequest>, I>>(object: I): FileTransferSendRequest {
    const message = createBaseFileTransferSendRequest();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.include_hidden = object.include_hidden ?? false;
    message.file_num = object.file_num ?? 0;
    message.file_type = object.file_type ?? 0;
    return message;
  },
};

function createBaseFileTransferSendConfirmRequest(): FileTransferSendConfirmRequest {
  return { id: 0, file_num: 0, skip: undefined, offset_blk: undefined };
}

export const FileTransferSendConfirmRequest = {
  encode(message: FileTransferSendConfirmRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.file_num !== 0) {
      writer.uint32(16).sint32(message.file_num);
    }
    if (message.skip !== undefined) {
      writer.uint32(24).bool(message.skip);
    }
    if (message.offset_blk !== undefined) {
      writer.uint32(32).uint32(message.offset_blk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferSendConfirmRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferSendConfirmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.file_num = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.skip = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset_blk = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferSendConfirmRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
      skip: isSet(object.skip) ? globalThis.Boolean(object.skip) : undefined,
      offset_blk: isSet(object.offset_blk) ? globalThis.Number(object.offset_blk) : undefined,
    };
  },

  toJSON(message: FileTransferSendConfirmRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    if (message.skip !== undefined) {
      obj.skip = message.skip;
    }
    if (message.offset_blk !== undefined) {
      obj.offset_blk = Math.round(message.offset_blk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferSendConfirmRequest>, I>>(base?: I): FileTransferSendConfirmRequest {
    return FileTransferSendConfirmRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferSendConfirmRequest>, I>>(
    object: I,
  ): FileTransferSendConfirmRequest {
    const message = createBaseFileTransferSendConfirmRequest();
    message.id = object.id ?? 0;
    message.file_num = object.file_num ?? 0;
    message.skip = object.skip ?? undefined;
    message.offset_blk = object.offset_blk ?? undefined;
    return message;
  },
};

function createBaseFileTransferDone(): FileTransferDone {
  return { id: 0, file_num: 0 };
}

export const FileTransferDone = {
  encode(message: FileTransferDone, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.file_num !== 0) {
      writer.uint32(16).sint32(message.file_num);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferDone {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferDone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.file_num = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferDone {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
    };
  },

  toJSON(message: FileTransferDone): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferDone>, I>>(base?: I): FileTransferDone {
    return FileTransferDone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferDone>, I>>(object: I): FileTransferDone {
    const message = createBaseFileTransferDone();
    message.id = object.id ?? 0;
    message.file_num = object.file_num ?? 0;
    return message;
  },
};

function createBaseFileTransferReceiveRequest(): FileTransferReceiveRequest {
  return { id: 0, path: "", files: [], file_num: 0, total_size: 0 };
}

export const FileTransferReceiveRequest = {
  encode(message: FileTransferReceiveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    for (const v of message.files) {
      FileEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.file_num !== 0) {
      writer.uint32(32).int32(message.file_num);
    }
    if (message.total_size !== 0) {
      writer.uint32(40).uint64(message.total_size);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileTransferReceiveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTransferReceiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.files.push(FileEntry.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.file_num = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.total_size = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTransferReceiveRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileEntry.fromJSON(e)) : [],
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
      total_size: isSet(object.total_size) ? globalThis.Number(object.total_size) : 0,
    };
  },

  toJSON(message: FileTransferReceiveRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileEntry.toJSON(e));
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    if (message.total_size !== 0) {
      obj.total_size = Math.round(message.total_size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileTransferReceiveRequest>, I>>(base?: I): FileTransferReceiveRequest {
    return FileTransferReceiveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileTransferReceiveRequest>, I>>(object: I): FileTransferReceiveRequest {
    const message = createBaseFileTransferReceiveRequest();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.files = object.files?.map((e) => FileEntry.fromPartial(e)) || [];
    message.file_num = object.file_num ?? 0;
    message.total_size = object.total_size ?? 0;
    return message;
  },
};

function createBaseFileRemoveDir(): FileRemoveDir {
  return { id: 0, path: "", recursive: false };
}

export const FileRemoveDir = {
  encode(message: FileRemoveDir, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(24).bool(message.recursive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileRemoveDir {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileRemoveDir();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recursive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileRemoveDir {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : false,
    };
  },

  toJSON(message: FileRemoveDir): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileRemoveDir>, I>>(base?: I): FileRemoveDir {
    return FileRemoveDir.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileRemoveDir>, I>>(object: I): FileRemoveDir {
    const message = createBaseFileRemoveDir();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  },
};

function createBaseFileRemoveFile(): FileRemoveFile {
  return { id: 0, path: "", file_num: 0 };
}

export const FileRemoveFile = {
  encode(message: FileRemoveFile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.file_num !== 0) {
      writer.uint32(24).sint32(message.file_num);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileRemoveFile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileRemoveFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.file_num = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileRemoveFile {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      file_num: isSet(object.file_num) ? globalThis.Number(object.file_num) : 0,
    };
  },

  toJSON(message: FileRemoveFile): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.file_num !== 0) {
      obj.file_num = Math.round(message.file_num);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileRemoveFile>, I>>(base?: I): FileRemoveFile {
    return FileRemoveFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileRemoveFile>, I>>(object: I): FileRemoveFile {
    const message = createBaseFileRemoveFile();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    message.file_num = object.file_num ?? 0;
    return message;
  },
};

function createBaseFileDirCreate(): FileDirCreate {
  return { id: 0, path: "" };
}

export const FileDirCreate = {
  encode(message: FileDirCreate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileDirCreate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDirCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDirCreate {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: FileDirCreate): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileDirCreate>, I>>(base?: I): FileDirCreate {
    return FileDirCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileDirCreate>, I>>(object: I): FileDirCreate {
    const message = createBaseFileDirCreate();
    message.id = object.id ?? 0;
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseCliprdrMonitorReady(): CliprdrMonitorReady {
  return {};
}

export const CliprdrMonitorReady = {
  encode(_: CliprdrMonitorReady, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrMonitorReady {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrMonitorReady();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CliprdrMonitorReady {
    return {};
  },

  toJSON(_: CliprdrMonitorReady): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrMonitorReady>, I>>(base?: I): CliprdrMonitorReady {
    return CliprdrMonitorReady.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrMonitorReady>, I>>(_: I): CliprdrMonitorReady {
    const message = createBaseCliprdrMonitorReady();
    return message;
  },
};

function createBaseCliprdrFormat(): CliprdrFormat {
  return { id: 0, format: "" };
}

export const CliprdrFormat = {
  encode(message: CliprdrFormat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrFormat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrFormat {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: CliprdrFormat): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrFormat>, I>>(base?: I): CliprdrFormat {
    return CliprdrFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrFormat>, I>>(object: I): CliprdrFormat {
    const message = createBaseCliprdrFormat();
    message.id = object.id ?? 0;
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseCliprdrServerFormatList(): CliprdrServerFormatList {
  return { formats: [] };
}

export const CliprdrServerFormatList = {
  encode(message: CliprdrServerFormatList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.formats) {
      CliprdrFormat.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrServerFormatList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrServerFormatList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.formats.push(CliprdrFormat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrServerFormatList {
    return {
      formats: globalThis.Array.isArray(object?.formats)
        ? object.formats.map((e: any) => CliprdrFormat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CliprdrServerFormatList): unknown {
    const obj: any = {};
    if (message.formats?.length) {
      obj.formats = message.formats.map((e) => CliprdrFormat.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrServerFormatList>, I>>(base?: I): CliprdrServerFormatList {
    return CliprdrServerFormatList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrServerFormatList>, I>>(object: I): CliprdrServerFormatList {
    const message = createBaseCliprdrServerFormatList();
    message.formats = object.formats?.map((e) => CliprdrFormat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCliprdrServerFormatListResponse(): CliprdrServerFormatListResponse {
  return { msg_flags: 0 };
}

export const CliprdrServerFormatListResponse = {
  encode(message: CliprdrServerFormatListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msg_flags !== 0) {
      writer.uint32(16).int32(message.msg_flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrServerFormatListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrServerFormatListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.msg_flags = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrServerFormatListResponse {
    return { msg_flags: isSet(object.msg_flags) ? globalThis.Number(object.msg_flags) : 0 };
  },

  toJSON(message: CliprdrServerFormatListResponse): unknown {
    const obj: any = {};
    if (message.msg_flags !== 0) {
      obj.msg_flags = Math.round(message.msg_flags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrServerFormatListResponse>, I>>(base?: I): CliprdrServerFormatListResponse {
    return CliprdrServerFormatListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrServerFormatListResponse>, I>>(
    object: I,
  ): CliprdrServerFormatListResponse {
    const message = createBaseCliprdrServerFormatListResponse();
    message.msg_flags = object.msg_flags ?? 0;
    return message;
  },
};

function createBaseCliprdrServerFormatDataRequest(): CliprdrServerFormatDataRequest {
  return { requested_format_id: 0 };
}

export const CliprdrServerFormatDataRequest = {
  encode(message: CliprdrServerFormatDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requested_format_id !== 0) {
      writer.uint32(16).int32(message.requested_format_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrServerFormatDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrServerFormatDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.requested_format_id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrServerFormatDataRequest {
    return {
      requested_format_id: isSet(object.requested_format_id) ? globalThis.Number(object.requested_format_id) : 0,
    };
  },

  toJSON(message: CliprdrServerFormatDataRequest): unknown {
    const obj: any = {};
    if (message.requested_format_id !== 0) {
      obj.requested_format_id = Math.round(message.requested_format_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrServerFormatDataRequest>, I>>(base?: I): CliprdrServerFormatDataRequest {
    return CliprdrServerFormatDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrServerFormatDataRequest>, I>>(
    object: I,
  ): CliprdrServerFormatDataRequest {
    const message = createBaseCliprdrServerFormatDataRequest();
    message.requested_format_id = object.requested_format_id ?? 0;
    return message;
  },
};

function createBaseCliprdrServerFormatDataResponse(): CliprdrServerFormatDataResponse {
  return { msg_flags: 0, format_data: new Uint8Array(0) };
}

export const CliprdrServerFormatDataResponse = {
  encode(message: CliprdrServerFormatDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msg_flags !== 0) {
      writer.uint32(16).int32(message.msg_flags);
    }
    if (message.format_data.length !== 0) {
      writer.uint32(26).bytes(message.format_data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrServerFormatDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrServerFormatDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.msg_flags = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format_data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrServerFormatDataResponse {
    return {
      msg_flags: isSet(object.msg_flags) ? globalThis.Number(object.msg_flags) : 0,
      format_data: isSet(object.format_data) ? bytesFromBase64(object.format_data) : new Uint8Array(0),
    };
  },

  toJSON(message: CliprdrServerFormatDataResponse): unknown {
    const obj: any = {};
    if (message.msg_flags !== 0) {
      obj.msg_flags = Math.round(message.msg_flags);
    }
    if (message.format_data.length !== 0) {
      obj.format_data = base64FromBytes(message.format_data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrServerFormatDataResponse>, I>>(base?: I): CliprdrServerFormatDataResponse {
    return CliprdrServerFormatDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrServerFormatDataResponse>, I>>(
    object: I,
  ): CliprdrServerFormatDataResponse {
    const message = createBaseCliprdrServerFormatDataResponse();
    message.msg_flags = object.msg_flags ?? 0;
    message.format_data = object.format_data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCliprdrFileContentsRequest(): CliprdrFileContentsRequest {
  return {
    stream_id: 0,
    list_index: 0,
    dw_flags: 0,
    n_position_low: 0,
    n_position_high: 0,
    cb_requested: 0,
    have_clip_data_id: false,
    clip_data_id: 0,
  };
}

export const CliprdrFileContentsRequest = {
  encode(message: CliprdrFileContentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stream_id !== 0) {
      writer.uint32(16).int32(message.stream_id);
    }
    if (message.list_index !== 0) {
      writer.uint32(24).int32(message.list_index);
    }
    if (message.dw_flags !== 0) {
      writer.uint32(32).int32(message.dw_flags);
    }
    if (message.n_position_low !== 0) {
      writer.uint32(40).int32(message.n_position_low);
    }
    if (message.n_position_high !== 0) {
      writer.uint32(48).int32(message.n_position_high);
    }
    if (message.cb_requested !== 0) {
      writer.uint32(56).int32(message.cb_requested);
    }
    if (message.have_clip_data_id !== false) {
      writer.uint32(64).bool(message.have_clip_data_id);
    }
    if (message.clip_data_id !== 0) {
      writer.uint32(72).int32(message.clip_data_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrFileContentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrFileContentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stream_id = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.list_index = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dw_flags = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.n_position_low = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.n_position_high = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cb_requested = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.have_clip_data_id = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.clip_data_id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrFileContentsRequest {
    return {
      stream_id: isSet(object.stream_id) ? globalThis.Number(object.stream_id) : 0,
      list_index: isSet(object.list_index) ? globalThis.Number(object.list_index) : 0,
      dw_flags: isSet(object.dw_flags) ? globalThis.Number(object.dw_flags) : 0,
      n_position_low: isSet(object.n_position_low) ? globalThis.Number(object.n_position_low) : 0,
      n_position_high: isSet(object.n_position_high) ? globalThis.Number(object.n_position_high) : 0,
      cb_requested: isSet(object.cb_requested) ? globalThis.Number(object.cb_requested) : 0,
      have_clip_data_id: isSet(object.have_clip_data_id) ? globalThis.Boolean(object.have_clip_data_id) : false,
      clip_data_id: isSet(object.clip_data_id) ? globalThis.Number(object.clip_data_id) : 0,
    };
  },

  toJSON(message: CliprdrFileContentsRequest): unknown {
    const obj: any = {};
    if (message.stream_id !== 0) {
      obj.stream_id = Math.round(message.stream_id);
    }
    if (message.list_index !== 0) {
      obj.list_index = Math.round(message.list_index);
    }
    if (message.dw_flags !== 0) {
      obj.dw_flags = Math.round(message.dw_flags);
    }
    if (message.n_position_low !== 0) {
      obj.n_position_low = Math.round(message.n_position_low);
    }
    if (message.n_position_high !== 0) {
      obj.n_position_high = Math.round(message.n_position_high);
    }
    if (message.cb_requested !== 0) {
      obj.cb_requested = Math.round(message.cb_requested);
    }
    if (message.have_clip_data_id !== false) {
      obj.have_clip_data_id = message.have_clip_data_id;
    }
    if (message.clip_data_id !== 0) {
      obj.clip_data_id = Math.round(message.clip_data_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrFileContentsRequest>, I>>(base?: I): CliprdrFileContentsRequest {
    return CliprdrFileContentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrFileContentsRequest>, I>>(object: I): CliprdrFileContentsRequest {
    const message = createBaseCliprdrFileContentsRequest();
    message.stream_id = object.stream_id ?? 0;
    message.list_index = object.list_index ?? 0;
    message.dw_flags = object.dw_flags ?? 0;
    message.n_position_low = object.n_position_low ?? 0;
    message.n_position_high = object.n_position_high ?? 0;
    message.cb_requested = object.cb_requested ?? 0;
    message.have_clip_data_id = object.have_clip_data_id ?? false;
    message.clip_data_id = object.clip_data_id ?? 0;
    return message;
  },
};

function createBaseCliprdrFileContentsResponse(): CliprdrFileContentsResponse {
  return { msg_flags: 0, stream_id: 0, requested_data: new Uint8Array(0) };
}

export const CliprdrFileContentsResponse = {
  encode(message: CliprdrFileContentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msg_flags !== 0) {
      writer.uint32(24).int32(message.msg_flags);
    }
    if (message.stream_id !== 0) {
      writer.uint32(32).int32(message.stream_id);
    }
    if (message.requested_data.length !== 0) {
      writer.uint32(42).bytes(message.requested_data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrFileContentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrFileContentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.msg_flags = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.stream_id = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requested_data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CliprdrFileContentsResponse {
    return {
      msg_flags: isSet(object.msg_flags) ? globalThis.Number(object.msg_flags) : 0,
      stream_id: isSet(object.stream_id) ? globalThis.Number(object.stream_id) : 0,
      requested_data: isSet(object.requested_data) ? bytesFromBase64(object.requested_data) : new Uint8Array(0),
    };
  },

  toJSON(message: CliprdrFileContentsResponse): unknown {
    const obj: any = {};
    if (message.msg_flags !== 0) {
      obj.msg_flags = Math.round(message.msg_flags);
    }
    if (message.stream_id !== 0) {
      obj.stream_id = Math.round(message.stream_id);
    }
    if (message.requested_data.length !== 0) {
      obj.requested_data = base64FromBytes(message.requested_data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrFileContentsResponse>, I>>(base?: I): CliprdrFileContentsResponse {
    return CliprdrFileContentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrFileContentsResponse>, I>>(object: I): CliprdrFileContentsResponse {
    const message = createBaseCliprdrFileContentsResponse();
    message.msg_flags = object.msg_flags ?? 0;
    message.stream_id = object.stream_id ?? 0;
    message.requested_data = object.requested_data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCliprdrTryEmpty(): CliprdrTryEmpty {
  return {};
}

export const CliprdrTryEmpty = {
  encode(_: CliprdrTryEmpty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CliprdrTryEmpty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdrTryEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CliprdrTryEmpty {
    return {};
  },

  toJSON(_: CliprdrTryEmpty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CliprdrTryEmpty>, I>>(base?: I): CliprdrTryEmpty {
    return CliprdrTryEmpty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CliprdrTryEmpty>, I>>(_: I): CliprdrTryEmpty {
    const message = createBaseCliprdrTryEmpty();
    return message;
  },
};

function createBaseCliprdr(): Cliprdr {
  return {
    ready: undefined,
    format_list: undefined,
    format_list_response: undefined,
    format_data_request: undefined,
    format_data_response: undefined,
    file_contents_request: undefined,
    file_contents_response: undefined,
    try_empty: undefined,
  };
}

export const Cliprdr = {
  encode(message: Cliprdr, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ready !== undefined) {
      CliprdrMonitorReady.encode(message.ready, writer.uint32(10).fork()).ldelim();
    }
    if (message.format_list !== undefined) {
      CliprdrServerFormatList.encode(message.format_list, writer.uint32(18).fork()).ldelim();
    }
    if (message.format_list_response !== undefined) {
      CliprdrServerFormatListResponse.encode(message.format_list_response, writer.uint32(26).fork()).ldelim();
    }
    if (message.format_data_request !== undefined) {
      CliprdrServerFormatDataRequest.encode(message.format_data_request, writer.uint32(34).fork()).ldelim();
    }
    if (message.format_data_response !== undefined) {
      CliprdrServerFormatDataResponse.encode(message.format_data_response, writer.uint32(42).fork()).ldelim();
    }
    if (message.file_contents_request !== undefined) {
      CliprdrFileContentsRequest.encode(message.file_contents_request, writer.uint32(50).fork()).ldelim();
    }
    if (message.file_contents_response !== undefined) {
      CliprdrFileContentsResponse.encode(message.file_contents_response, writer.uint32(58).fork()).ldelim();
    }
    if (message.try_empty !== undefined) {
      CliprdrTryEmpty.encode(message.try_empty, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Cliprdr {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCliprdr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ready = CliprdrMonitorReady.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format_list = CliprdrServerFormatList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format_list_response = CliprdrServerFormatListResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.format_data_request = CliprdrServerFormatDataRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.format_data_response = CliprdrServerFormatDataResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.file_contents_request = CliprdrFileContentsRequest.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.file_contents_response = CliprdrFileContentsResponse.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.try_empty = CliprdrTryEmpty.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cliprdr {
    return {
      ready: isSet(object.ready) ? CliprdrMonitorReady.fromJSON(object.ready) : undefined,
      format_list: isSet(object.format_list) ? CliprdrServerFormatList.fromJSON(object.format_list) : undefined,
      format_list_response: isSet(object.format_list_response)
        ? CliprdrServerFormatListResponse.fromJSON(object.format_list_response)
        : undefined,
      format_data_request: isSet(object.format_data_request)
        ? CliprdrServerFormatDataRequest.fromJSON(object.format_data_request)
        : undefined,
      format_data_response: isSet(object.format_data_response)
        ? CliprdrServerFormatDataResponse.fromJSON(object.format_data_response)
        : undefined,
      file_contents_request: isSet(object.file_contents_request)
        ? CliprdrFileContentsRequest.fromJSON(object.file_contents_request)
        : undefined,
      file_contents_response: isSet(object.file_contents_response)
        ? CliprdrFileContentsResponse.fromJSON(object.file_contents_response)
        : undefined,
      try_empty: isSet(object.try_empty) ? CliprdrTryEmpty.fromJSON(object.try_empty) : undefined,
    };
  },

  toJSON(message: Cliprdr): unknown {
    const obj: any = {};
    if (message.ready !== undefined) {
      obj.ready = CliprdrMonitorReady.toJSON(message.ready);
    }
    if (message.format_list !== undefined) {
      obj.format_list = CliprdrServerFormatList.toJSON(message.format_list);
    }
    if (message.format_list_response !== undefined) {
      obj.format_list_response = CliprdrServerFormatListResponse.toJSON(message.format_list_response);
    }
    if (message.format_data_request !== undefined) {
      obj.format_data_request = CliprdrServerFormatDataRequest.toJSON(message.format_data_request);
    }
    if (message.format_data_response !== undefined) {
      obj.format_data_response = CliprdrServerFormatDataResponse.toJSON(message.format_data_response);
    }
    if (message.file_contents_request !== undefined) {
      obj.file_contents_request = CliprdrFileContentsRequest.toJSON(message.file_contents_request);
    }
    if (message.file_contents_response !== undefined) {
      obj.file_contents_response = CliprdrFileContentsResponse.toJSON(message.file_contents_response);
    }
    if (message.try_empty !== undefined) {
      obj.try_empty = CliprdrTryEmpty.toJSON(message.try_empty);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cliprdr>, I>>(base?: I): Cliprdr {
    return Cliprdr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cliprdr>, I>>(object: I): Cliprdr {
    const message = createBaseCliprdr();
    message.ready = (object.ready !== undefined && object.ready !== null)
      ? CliprdrMonitorReady.fromPartial(object.ready)
      : undefined;
    message.format_list = (object.format_list !== undefined && object.format_list !== null)
      ? CliprdrServerFormatList.fromPartial(object.format_list)
      : undefined;
    message.format_list_response = (object.format_list_response !== undefined && object.format_list_response !== null)
      ? CliprdrServerFormatListResponse.fromPartial(object.format_list_response)
      : undefined;
    message.format_data_request = (object.format_data_request !== undefined && object.format_data_request !== null)
      ? CliprdrServerFormatDataRequest.fromPartial(object.format_data_request)
      : undefined;
    message.format_data_response = (object.format_data_response !== undefined && object.format_data_response !== null)
      ? CliprdrServerFormatDataResponse.fromPartial(object.format_data_response)
      : undefined;
    message.file_contents_request =
      (object.file_contents_request !== undefined && object.file_contents_request !== null)
        ? CliprdrFileContentsRequest.fromPartial(object.file_contents_request)
        : undefined;
    message.file_contents_response =
      (object.file_contents_response !== undefined && object.file_contents_response !== null)
        ? CliprdrFileContentsResponse.fromPartial(object.file_contents_response)
        : undefined;
    message.try_empty = (object.try_empty !== undefined && object.try_empty !== null)
      ? CliprdrTryEmpty.fromPartial(object.try_empty)
      : undefined;
    return message;
  },
};

function createBaseResolution(): Resolution {
  return { width: 0, height: 0 };
}

export const Resolution = {
  encode(message: Resolution, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resolution {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resolution {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: Resolution): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resolution>, I>>(base?: I): Resolution {
    return Resolution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resolution>, I>>(object: I): Resolution {
    const message = createBaseResolution();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseDisplayResolution(): DisplayResolution {
  return { display: 0, resolution: undefined };
}

export const DisplayResolution = {
  encode(message: DisplayResolution, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.display !== 0) {
      writer.uint32(8).int32(message.display);
    }
    if (message.resolution !== undefined) {
      Resolution.encode(message.resolution, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisplayResolution {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayResolution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.display = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resolution = Resolution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayResolution {
    return {
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
      resolution: isSet(object.resolution) ? Resolution.fromJSON(object.resolution) : undefined,
    };
  },

  toJSON(message: DisplayResolution): unknown {
    const obj: any = {};
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    if (message.resolution !== undefined) {
      obj.resolution = Resolution.toJSON(message.resolution);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayResolution>, I>>(base?: I): DisplayResolution {
    return DisplayResolution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayResolution>, I>>(object: I): DisplayResolution {
    const message = createBaseDisplayResolution();
    message.display = object.display ?? 0;
    message.resolution = (object.resolution !== undefined && object.resolution !== null)
      ? Resolution.fromPartial(object.resolution)
      : undefined;
    return message;
  },
};

function createBaseSupportedResolutions(): SupportedResolutions {
  return { resolutions: [] };
}

export const SupportedResolutions = {
  encode(message: SupportedResolutions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resolutions) {
      Resolution.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupportedResolutions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedResolutions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resolutions.push(Resolution.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedResolutions {
    return {
      resolutions: globalThis.Array.isArray(object?.resolutions)
        ? object.resolutions.map((e: any) => Resolution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SupportedResolutions): unknown {
    const obj: any = {};
    if (message.resolutions?.length) {
      obj.resolutions = message.resolutions.map((e) => Resolution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupportedResolutions>, I>>(base?: I): SupportedResolutions {
    return SupportedResolutions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupportedResolutions>, I>>(object: I): SupportedResolutions {
    const message = createBaseSupportedResolutions();
    message.resolutions = object.resolutions?.map((e) => Resolution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwitchDisplay(): SwitchDisplay {
  return {
    display: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    cursor_embedded: false,
    resolutions: undefined,
    original_resolution: undefined,
  };
}

export const SwitchDisplay = {
  encode(message: SwitchDisplay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.display !== 0) {
      writer.uint32(8).int32(message.display);
    }
    if (message.x !== 0) {
      writer.uint32(16).sint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(24).sint32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.cursor_embedded !== false) {
      writer.uint32(48).bool(message.cursor_embedded);
    }
    if (message.resolutions !== undefined) {
      SupportedResolutions.encode(message.resolutions, writer.uint32(58).fork()).ldelim();
    }
    if (message.original_resolution !== undefined) {
      Resolution.encode(message.original_resolution, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwitchDisplay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchDisplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.display = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.x = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.y = reader.sint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cursor_embedded = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.resolutions = SupportedResolutions.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.original_resolution = Resolution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwitchDisplay {
    return {
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      cursor_embedded: isSet(object.cursor_embedded) ? globalThis.Boolean(object.cursor_embedded) : false,
      resolutions: isSet(object.resolutions) ? SupportedResolutions.fromJSON(object.resolutions) : undefined,
      original_resolution: isSet(object.original_resolution)
        ? Resolution.fromJSON(object.original_resolution)
        : undefined,
    };
  },

  toJSON(message: SwitchDisplay): unknown {
    const obj: any = {};
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.cursor_embedded !== false) {
      obj.cursor_embedded = message.cursor_embedded;
    }
    if (message.resolutions !== undefined) {
      obj.resolutions = SupportedResolutions.toJSON(message.resolutions);
    }
    if (message.original_resolution !== undefined) {
      obj.original_resolution = Resolution.toJSON(message.original_resolution);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwitchDisplay>, I>>(base?: I): SwitchDisplay {
    return SwitchDisplay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwitchDisplay>, I>>(object: I): SwitchDisplay {
    const message = createBaseSwitchDisplay();
    message.display = object.display ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.cursor_embedded = object.cursor_embedded ?? false;
    message.resolutions = (object.resolutions !== undefined && object.resolutions !== null)
      ? SupportedResolutions.fromPartial(object.resolutions)
      : undefined;
    message.original_resolution = (object.original_resolution !== undefined && object.original_resolution !== null)
      ? Resolution.fromPartial(object.original_resolution)
      : undefined;
    return message;
  },
};

function createBaseCaptureDisplays(): CaptureDisplays {
  return { add: [], sub: [], set: [] };
}

export const CaptureDisplays = {
  encode(message: CaptureDisplays, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.add) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.sub) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.set) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureDisplays {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureDisplays();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.add.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.add.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.sub.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sub.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.set.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.set.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureDisplays {
    return {
      add: globalThis.Array.isArray(object?.add) ? object.add.map((e: any) => globalThis.Number(e)) : [],
      sub: globalThis.Array.isArray(object?.sub) ? object.sub.map((e: any) => globalThis.Number(e)) : [],
      set: globalThis.Array.isArray(object?.set) ? object.set.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CaptureDisplays): unknown {
    const obj: any = {};
    if (message.add?.length) {
      obj.add = message.add.map((e) => Math.round(e));
    }
    if (message.sub?.length) {
      obj.sub = message.sub.map((e) => Math.round(e));
    }
    if (message.set?.length) {
      obj.set = message.set.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureDisplays>, I>>(base?: I): CaptureDisplays {
    return CaptureDisplays.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureDisplays>, I>>(object: I): CaptureDisplays {
    const message = createBaseCaptureDisplays();
    message.add = object.add?.map((e) => e) || [];
    message.sub = object.sub?.map((e) => e) || [];
    message.set = object.set?.map((e) => e) || [];
    return message;
  },
};

function createBaseToggleVirtualDisplay(): ToggleVirtualDisplay {
  return { display: 0, on: false };
}

export const ToggleVirtualDisplay = {
  encode(message: ToggleVirtualDisplay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.display !== 0) {
      writer.uint32(8).int32(message.display);
    }
    if (message.on !== false) {
      writer.uint32(16).bool(message.on);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToggleVirtualDisplay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleVirtualDisplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.display = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.on = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToggleVirtualDisplay {
    return {
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
      on: isSet(object.on) ? globalThis.Boolean(object.on) : false,
    };
  },

  toJSON(message: ToggleVirtualDisplay): unknown {
    const obj: any = {};
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    if (message.on !== false) {
      obj.on = message.on;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToggleVirtualDisplay>, I>>(base?: I): ToggleVirtualDisplay {
    return ToggleVirtualDisplay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleVirtualDisplay>, I>>(object: I): ToggleVirtualDisplay {
    const message = createBaseToggleVirtualDisplay();
    message.display = object.display ?? 0;
    message.on = object.on ?? false;
    return message;
  },
};

function createBaseTogglePrivacyMode(): TogglePrivacyMode {
  return { impl_key: "", on: false };
}

export const TogglePrivacyMode = {
  encode(message: TogglePrivacyMode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.impl_key !== "") {
      writer.uint32(10).string(message.impl_key);
    }
    if (message.on !== false) {
      writer.uint32(16).bool(message.on);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TogglePrivacyMode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTogglePrivacyMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.impl_key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.on = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TogglePrivacyMode {
    return {
      impl_key: isSet(object.impl_key) ? globalThis.String(object.impl_key) : "",
      on: isSet(object.on) ? globalThis.Boolean(object.on) : false,
    };
  },

  toJSON(message: TogglePrivacyMode): unknown {
    const obj: any = {};
    if (message.impl_key !== "") {
      obj.impl_key = message.impl_key;
    }
    if (message.on !== false) {
      obj.on = message.on;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TogglePrivacyMode>, I>>(base?: I): TogglePrivacyMode {
    return TogglePrivacyMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TogglePrivacyMode>, I>>(object: I): TogglePrivacyMode {
    const message = createBaseTogglePrivacyMode();
    message.impl_key = object.impl_key ?? "";
    message.on = object.on ?? false;
    return message;
  },
};

function createBasePermissionInfo(): PermissionInfo {
  return { permission: 0, enabled: false };
}

export const PermissionInfo = {
  encode(message: PermissionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permission !== 0) {
      writer.uint32(8).int32(message.permission);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.permission = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionInfo {
    return {
      permission: isSet(object.permission) ? permissionInfo_PermissionFromJSON(object.permission) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: PermissionInfo): unknown {
    const obj: any = {};
    if (message.permission !== 0) {
      obj.permission = permissionInfo_PermissionToJSON(message.permission);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionInfo>, I>>(base?: I): PermissionInfo {
    return PermissionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionInfo>, I>>(object: I): PermissionInfo {
    const message = createBasePermissionInfo();
    message.permission = object.permission ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseSupportedDecoding(): SupportedDecoding {
  return {
    ability_vp9: 0,
    ability_h264: 0,
    ability_h265: 0,
    prefer: 0,
    ability_vp8: 0,
    ability_av1: 0,
    i444: undefined,
    prefer_chroma: 0,
  };
}

export const SupportedDecoding = {
  encode(message: SupportedDecoding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ability_vp9 !== 0) {
      writer.uint32(8).int32(message.ability_vp9);
    }
    if (message.ability_h264 !== 0) {
      writer.uint32(16).int32(message.ability_h264);
    }
    if (message.ability_h265 !== 0) {
      writer.uint32(24).int32(message.ability_h265);
    }
    if (message.prefer !== 0) {
      writer.uint32(32).int32(message.prefer);
    }
    if (message.ability_vp8 !== 0) {
      writer.uint32(40).int32(message.ability_vp8);
    }
    if (message.ability_av1 !== 0) {
      writer.uint32(48).int32(message.ability_av1);
    }
    if (message.i444 !== undefined) {
      CodecAbility.encode(message.i444, writer.uint32(58).fork()).ldelim();
    }
    if (message.prefer_chroma !== 0) {
      writer.uint32(64).int32(message.prefer_chroma);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SupportedDecoding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedDecoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ability_vp9 = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ability_h264 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ability_h265 = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.prefer = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ability_vp8 = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ability_av1 = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.i444 = CodecAbility.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.prefer_chroma = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedDecoding {
    return {
      ability_vp9: isSet(object.ability_vp9) ? globalThis.Number(object.ability_vp9) : 0,
      ability_h264: isSet(object.ability_h264) ? globalThis.Number(object.ability_h264) : 0,
      ability_h265: isSet(object.ability_h265) ? globalThis.Number(object.ability_h265) : 0,
      prefer: isSet(object.prefer) ? supportedDecoding_PreferCodecFromJSON(object.prefer) : 0,
      ability_vp8: isSet(object.ability_vp8) ? globalThis.Number(object.ability_vp8) : 0,
      ability_av1: isSet(object.ability_av1) ? globalThis.Number(object.ability_av1) : 0,
      i444: isSet(object.i444) ? CodecAbility.fromJSON(object.i444) : undefined,
      prefer_chroma: isSet(object.prefer_chroma) ? chromaFromJSON(object.prefer_chroma) : 0,
    };
  },

  toJSON(message: SupportedDecoding): unknown {
    const obj: any = {};
    if (message.ability_vp9 !== 0) {
      obj.ability_vp9 = Math.round(message.ability_vp9);
    }
    if (message.ability_h264 !== 0) {
      obj.ability_h264 = Math.round(message.ability_h264);
    }
    if (message.ability_h265 !== 0) {
      obj.ability_h265 = Math.round(message.ability_h265);
    }
    if (message.prefer !== 0) {
      obj.prefer = supportedDecoding_PreferCodecToJSON(message.prefer);
    }
    if (message.ability_vp8 !== 0) {
      obj.ability_vp8 = Math.round(message.ability_vp8);
    }
    if (message.ability_av1 !== 0) {
      obj.ability_av1 = Math.round(message.ability_av1);
    }
    if (message.i444 !== undefined) {
      obj.i444 = CodecAbility.toJSON(message.i444);
    }
    if (message.prefer_chroma !== 0) {
      obj.prefer_chroma = chromaToJSON(message.prefer_chroma);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SupportedDecoding>, I>>(base?: I): SupportedDecoding {
    return SupportedDecoding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SupportedDecoding>, I>>(object: I): SupportedDecoding {
    const message = createBaseSupportedDecoding();
    message.ability_vp9 = object.ability_vp9 ?? 0;
    message.ability_h264 = object.ability_h264 ?? 0;
    message.ability_h265 = object.ability_h265 ?? 0;
    message.prefer = object.prefer ?? 0;
    message.ability_vp8 = object.ability_vp8 ?? 0;
    message.ability_av1 = object.ability_av1 ?? 0;
    message.i444 = (object.i444 !== undefined && object.i444 !== null)
      ? CodecAbility.fromPartial(object.i444)
      : undefined;
    message.prefer_chroma = object.prefer_chroma ?? 0;
    return message;
  },
};

function createBaseOptionMessage(): OptionMessage {
  return {
    image_quality: 0,
    lock_after_session_end: 0,
    show_remote_cursor: 0,
    privacy_mode: 0,
    block_input: 0,
    custom_image_quality: 0,
    disable_audio: 0,
    disable_clipboard: 0,
    enable_file_transfer: 0,
    supported_decoding: undefined,
    custom_fps: 0,
    disable_keyboard: 0,
    follow_remote_cursor: 0,
    follow_remote_window: 0,
    disable_camera: 0,
  };
}

export const OptionMessage = {
  encode(message: OptionMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.image_quality !== 0) {
      writer.uint32(8).int32(message.image_quality);
    }
    if (message.lock_after_session_end !== 0) {
      writer.uint32(16).int32(message.lock_after_session_end);
    }
    if (message.show_remote_cursor !== 0) {
      writer.uint32(24).int32(message.show_remote_cursor);
    }
    if (message.privacy_mode !== 0) {
      writer.uint32(32).int32(message.privacy_mode);
    }
    if (message.block_input !== 0) {
      writer.uint32(40).int32(message.block_input);
    }
    if (message.custom_image_quality !== 0) {
      writer.uint32(48).int32(message.custom_image_quality);
    }
    if (message.disable_audio !== 0) {
      writer.uint32(56).int32(message.disable_audio);
    }
    if (message.disable_clipboard !== 0) {
      writer.uint32(64).int32(message.disable_clipboard);
    }
    if (message.enable_file_transfer !== 0) {
      writer.uint32(72).int32(message.enable_file_transfer);
    }
    if (message.supported_decoding !== undefined) {
      SupportedDecoding.encode(message.supported_decoding, writer.uint32(82).fork()).ldelim();
    }
    if (message.custom_fps !== 0) {
      writer.uint32(88).int32(message.custom_fps);
    }
    if (message.disable_keyboard !== 0) {
      writer.uint32(96).int32(message.disable_keyboard);
    }
    if (message.follow_remote_cursor !== 0) {
      writer.uint32(120).int32(message.follow_remote_cursor);
    }
    if (message.follow_remote_window !== 0) {
      writer.uint32(128).int32(message.follow_remote_window);
    }
    if (message.disable_camera !== 0) {
      writer.uint32(136).int32(message.disable_camera);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OptionMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.image_quality = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lock_after_session_end = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.show_remote_cursor = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.privacy_mode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.block_input = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.custom_image_quality = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.disable_audio = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.disable_clipboard = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.enable_file_transfer = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.supported_decoding = SupportedDecoding.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.custom_fps = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.disable_keyboard = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.follow_remote_cursor = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.follow_remote_window = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.disable_camera = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionMessage {
    return {
      image_quality: isSet(object.image_quality) ? imageQualityFromJSON(object.image_quality) : 0,
      lock_after_session_end: isSet(object.lock_after_session_end)
        ? optionMessage_BoolOptionFromJSON(object.lock_after_session_end)
        : 0,
      show_remote_cursor: isSet(object.show_remote_cursor)
        ? optionMessage_BoolOptionFromJSON(object.show_remote_cursor)
        : 0,
      privacy_mode: isSet(object.privacy_mode) ? optionMessage_BoolOptionFromJSON(object.privacy_mode) : 0,
      block_input: isSet(object.block_input) ? optionMessage_BoolOptionFromJSON(object.block_input) : 0,
      custom_image_quality: isSet(object.custom_image_quality) ? globalThis.Number(object.custom_image_quality) : 0,
      disable_audio: isSet(object.disable_audio) ? optionMessage_BoolOptionFromJSON(object.disable_audio) : 0,
      disable_clipboard: isSet(object.disable_clipboard)
        ? optionMessage_BoolOptionFromJSON(object.disable_clipboard)
        : 0,
      enable_file_transfer: isSet(object.enable_file_transfer)
        ? optionMessage_BoolOptionFromJSON(object.enable_file_transfer)
        : 0,
      supported_decoding: isSet(object.supported_decoding)
        ? SupportedDecoding.fromJSON(object.supported_decoding)
        : undefined,
      custom_fps: isSet(object.custom_fps) ? globalThis.Number(object.custom_fps) : 0,
      disable_keyboard: isSet(object.disable_keyboard) ? optionMessage_BoolOptionFromJSON(object.disable_keyboard) : 0,
      follow_remote_cursor: isSet(object.follow_remote_cursor)
        ? optionMessage_BoolOptionFromJSON(object.follow_remote_cursor)
        : 0,
      follow_remote_window: isSet(object.follow_remote_window)
        ? optionMessage_BoolOptionFromJSON(object.follow_remote_window)
        : 0,
      disable_camera: isSet(object.disable_camera) ? optionMessage_BoolOptionFromJSON(object.disable_camera) : 0,
    };
  },

  toJSON(message: OptionMessage): unknown {
    const obj: any = {};
    if (message.image_quality !== 0) {
      obj.image_quality = imageQualityToJSON(message.image_quality);
    }
    if (message.lock_after_session_end !== 0) {
      obj.lock_after_session_end = optionMessage_BoolOptionToJSON(message.lock_after_session_end);
    }
    if (message.show_remote_cursor !== 0) {
      obj.show_remote_cursor = optionMessage_BoolOptionToJSON(message.show_remote_cursor);
    }
    if (message.privacy_mode !== 0) {
      obj.privacy_mode = optionMessage_BoolOptionToJSON(message.privacy_mode);
    }
    if (message.block_input !== 0) {
      obj.block_input = optionMessage_BoolOptionToJSON(message.block_input);
    }
    if (message.custom_image_quality !== 0) {
      obj.custom_image_quality = Math.round(message.custom_image_quality);
    }
    if (message.disable_audio !== 0) {
      obj.disable_audio = optionMessage_BoolOptionToJSON(message.disable_audio);
    }
    if (message.disable_clipboard !== 0) {
      obj.disable_clipboard = optionMessage_BoolOptionToJSON(message.disable_clipboard);
    }
    if (message.enable_file_transfer !== 0) {
      obj.enable_file_transfer = optionMessage_BoolOptionToJSON(message.enable_file_transfer);
    }
    if (message.supported_decoding !== undefined) {
      obj.supported_decoding = SupportedDecoding.toJSON(message.supported_decoding);
    }
    if (message.custom_fps !== 0) {
      obj.custom_fps = Math.round(message.custom_fps);
    }
    if (message.disable_keyboard !== 0) {
      obj.disable_keyboard = optionMessage_BoolOptionToJSON(message.disable_keyboard);
    }
    if (message.follow_remote_cursor !== 0) {
      obj.follow_remote_cursor = optionMessage_BoolOptionToJSON(message.follow_remote_cursor);
    }
    if (message.follow_remote_window !== 0) {
      obj.follow_remote_window = optionMessage_BoolOptionToJSON(message.follow_remote_window);
    }
    if (message.disable_camera !== 0) {
      obj.disable_camera = optionMessage_BoolOptionToJSON(message.disable_camera);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionMessage>, I>>(base?: I): OptionMessage {
    return OptionMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionMessage>, I>>(object: I): OptionMessage {
    const message = createBaseOptionMessage();
    message.image_quality = object.image_quality ?? 0;
    message.lock_after_session_end = object.lock_after_session_end ?? 0;
    message.show_remote_cursor = object.show_remote_cursor ?? 0;
    message.privacy_mode = object.privacy_mode ?? 0;
    message.block_input = object.block_input ?? 0;
    message.custom_image_quality = object.custom_image_quality ?? 0;
    message.disable_audio = object.disable_audio ?? 0;
    message.disable_clipboard = object.disable_clipboard ?? 0;
    message.enable_file_transfer = object.enable_file_transfer ?? 0;
    message.supported_decoding = (object.supported_decoding !== undefined && object.supported_decoding !== null)
      ? SupportedDecoding.fromPartial(object.supported_decoding)
      : undefined;
    message.custom_fps = object.custom_fps ?? 0;
    message.disable_keyboard = object.disable_keyboard ?? 0;
    message.follow_remote_cursor = object.follow_remote_cursor ?? 0;
    message.follow_remote_window = object.follow_remote_window ?? 0;
    message.disable_camera = object.disable_camera ?? 0;
    return message;
  },
};

function createBaseTestDelay(): TestDelay {
  return { time: 0, from_client: false, last_delay: 0, target_bitrate: 0 };
}

export const TestDelay = {
  encode(message: TestDelay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.time !== 0) {
      writer.uint32(8).int64(message.time);
    }
    if (message.from_client !== false) {
      writer.uint32(16).bool(message.from_client);
    }
    if (message.last_delay !== 0) {
      writer.uint32(24).uint32(message.last_delay);
    }
    if (message.target_bitrate !== 0) {
      writer.uint32(32).uint32(message.target_bitrate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TestDelay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestDelay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.time = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.from_client = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.last_delay = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.target_bitrate = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestDelay {
    return {
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      from_client: isSet(object.from_client) ? globalThis.Boolean(object.from_client) : false,
      last_delay: isSet(object.last_delay) ? globalThis.Number(object.last_delay) : 0,
      target_bitrate: isSet(object.target_bitrate) ? globalThis.Number(object.target_bitrate) : 0,
    };
  },

  toJSON(message: TestDelay): unknown {
    const obj: any = {};
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.from_client !== false) {
      obj.from_client = message.from_client;
    }
    if (message.last_delay !== 0) {
      obj.last_delay = Math.round(message.last_delay);
    }
    if (message.target_bitrate !== 0) {
      obj.target_bitrate = Math.round(message.target_bitrate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestDelay>, I>>(base?: I): TestDelay {
    return TestDelay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestDelay>, I>>(object: I): TestDelay {
    const message = createBaseTestDelay();
    message.time = object.time ?? 0;
    message.from_client = object.from_client ?? false;
    message.last_delay = object.last_delay ?? 0;
    message.target_bitrate = object.target_bitrate ?? 0;
    return message;
  },
};

function createBasePublicKey(): PublicKey {
  return { asymmetric_value: new Uint8Array(0), symmetric_value: new Uint8Array(0) };
}

export const PublicKey = {
  encode(message: PublicKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.asymmetric_value.length !== 0) {
      writer.uint32(10).bytes(message.asymmetric_value);
    }
    if (message.symmetric_value.length !== 0) {
      writer.uint32(18).bytes(message.symmetric_value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublicKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asymmetric_value = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symmetric_value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKey {
    return {
      asymmetric_value: isSet(object.asymmetric_value) ? bytesFromBase64(object.asymmetric_value) : new Uint8Array(0),
      symmetric_value: isSet(object.symmetric_value) ? bytesFromBase64(object.symmetric_value) : new Uint8Array(0),
    };
  },

  toJSON(message: PublicKey): unknown {
    const obj: any = {};
    if (message.asymmetric_value.length !== 0) {
      obj.asymmetric_value = base64FromBytes(message.asymmetric_value);
    }
    if (message.symmetric_value.length !== 0) {
      obj.symmetric_value = base64FromBytes(message.symmetric_value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublicKey>, I>>(base?: I): PublicKey {
    return PublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicKey>, I>>(object: I): PublicKey {
    const message = createBasePublicKey();
    message.asymmetric_value = object.asymmetric_value ?? new Uint8Array(0);
    message.symmetric_value = object.symmetric_value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignedId(): SignedId {
  return { id: new Uint8Array(0) };
}

export const SignedId = {
  encode(message: SignedId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedId {
    return { id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0) };
  },

  toJSON(message: SignedId): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedId>, I>>(base?: I): SignedId {
    return SignedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedId>, I>>(object: I): SignedId {
    const message = createBaseSignedId();
    message.id = object.id ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAudioFormat(): AudioFormat {
  return { sample_rate: 0, channels: 0 };
}

export const AudioFormat = {
  encode(message: AudioFormat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sample_rate !== 0) {
      writer.uint32(8).uint32(message.sample_rate);
    }
    if (message.channels !== 0) {
      writer.uint32(16).uint32(message.channels);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioFormat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sample_rate = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channels = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioFormat {
    return {
      sample_rate: isSet(object.sample_rate) ? globalThis.Number(object.sample_rate) : 0,
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
    };
  },

  toJSON(message: AudioFormat): unknown {
    const obj: any = {};
    if (message.sample_rate !== 0) {
      obj.sample_rate = Math.round(message.sample_rate);
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioFormat>, I>>(base?: I): AudioFormat {
    return AudioFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioFormat>, I>>(object: I): AudioFormat {
    const message = createBaseAudioFormat();
    message.sample_rate = object.sample_rate ?? 0;
    message.channels = object.channels ?? 0;
    return message;
  },
};

function createBaseAudioFrame(): AudioFrame {
  return { data: new Uint8Array(0) };
}

export const AudioFrame = {
  encode(message: AudioFrame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioFrame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioFrame {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: AudioFrame): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioFrame>, I>>(base?: I): AudioFrame {
    return AudioFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioFrame>, I>>(object: I): AudioFrame {
    const message = createBaseAudioFrame();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMessageBox(): MessageBox {
  return { msgtype: "", title: "", text: "", link: "" };
}

export const MessageBox = {
  encode(message: MessageBox, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msgtype !== "") {
      writer.uint32(10).string(message.msgtype);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.link !== "") {
      writer.uint32(34).string(message.link);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageBox {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageBox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.msgtype = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.link = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageBox {
    return {
      msgtype: isSet(object.msgtype) ? globalThis.String(object.msgtype) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      link: isSet(object.link) ? globalThis.String(object.link) : "",
    };
  },

  toJSON(message: MessageBox): unknown {
    const obj: any = {};
    if (message.msgtype !== "") {
      obj.msgtype = message.msgtype;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.link !== "") {
      obj.link = message.link;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageBox>, I>>(base?: I): MessageBox {
    return MessageBox.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageBox>, I>>(object: I): MessageBox {
    const message = createBaseMessageBox();
    message.msgtype = object.msgtype ?? "";
    message.title = object.title ?? "";
    message.text = object.text ?? "";
    message.link = object.link ?? "";
    return message;
  },
};

function createBaseBackNotification(): BackNotification {
  return { privacy_mode_state: undefined, block_input_state: undefined, details: "", impl_key: "" };
}

export const BackNotification = {
  encode(message: BackNotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.privacy_mode_state !== undefined) {
      writer.uint32(8).int32(message.privacy_mode_state);
    }
    if (message.block_input_state !== undefined) {
      writer.uint32(16).int32(message.block_input_state);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.impl_key !== "") {
      writer.uint32(34).string(message.impl_key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BackNotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.privacy_mode_state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.block_input_state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.impl_key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackNotification {
    return {
      privacy_mode_state: isSet(object.privacy_mode_state)
        ? backNotification_PrivacyModeStateFromJSON(object.privacy_mode_state)
        : undefined,
      block_input_state: isSet(object.block_input_state)
        ? backNotification_BlockInputStateFromJSON(object.block_input_state)
        : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      impl_key: isSet(object.impl_key) ? globalThis.String(object.impl_key) : "",
    };
  },

  toJSON(message: BackNotification): unknown {
    const obj: any = {};
    if (message.privacy_mode_state !== undefined) {
      obj.privacy_mode_state = backNotification_PrivacyModeStateToJSON(message.privacy_mode_state);
    }
    if (message.block_input_state !== undefined) {
      obj.block_input_state = backNotification_BlockInputStateToJSON(message.block_input_state);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.impl_key !== "") {
      obj.impl_key = message.impl_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackNotification>, I>>(base?: I): BackNotification {
    return BackNotification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackNotification>, I>>(object: I): BackNotification {
    const message = createBaseBackNotification();
    message.privacy_mode_state = object.privacy_mode_state ?? undefined;
    message.block_input_state = object.block_input_state ?? undefined;
    message.details = object.details ?? "";
    message.impl_key = object.impl_key ?? "";
    return message;
  },
};

function createBaseElevationRequestWithLogon(): ElevationRequestWithLogon {
  return { username: "", password: "" };
}

export const ElevationRequestWithLogon = {
  encode(message: ElevationRequestWithLogon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ElevationRequestWithLogon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElevationRequestWithLogon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElevationRequestWithLogon {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: ElevationRequestWithLogon): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElevationRequestWithLogon>, I>>(base?: I): ElevationRequestWithLogon {
    return ElevationRequestWithLogon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElevationRequestWithLogon>, I>>(object: I): ElevationRequestWithLogon {
    const message = createBaseElevationRequestWithLogon();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseElevationRequest(): ElevationRequest {
  return { direct: undefined, logon: undefined };
}

export const ElevationRequest = {
  encode(message: ElevationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.direct !== undefined) {
      writer.uint32(8).bool(message.direct);
    }
    if (message.logon !== undefined) {
      ElevationRequestWithLogon.encode(message.logon, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ElevationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElevationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.direct = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logon = ElevationRequestWithLogon.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElevationRequest {
    return {
      direct: isSet(object.direct) ? globalThis.Boolean(object.direct) : undefined,
      logon: isSet(object.logon) ? ElevationRequestWithLogon.fromJSON(object.logon) : undefined,
    };
  },

  toJSON(message: ElevationRequest): unknown {
    const obj: any = {};
    if (message.direct !== undefined) {
      obj.direct = message.direct;
    }
    if (message.logon !== undefined) {
      obj.logon = ElevationRequestWithLogon.toJSON(message.logon);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElevationRequest>, I>>(base?: I): ElevationRequest {
    return ElevationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElevationRequest>, I>>(object: I): ElevationRequest {
    const message = createBaseElevationRequest();
    message.direct = object.direct ?? undefined;
    message.logon = (object.logon !== undefined && object.logon !== null)
      ? ElevationRequestWithLogon.fromPartial(object.logon)
      : undefined;
    return message;
  },
};

function createBaseSwitchSidesRequest(): SwitchSidesRequest {
  return { uuid: new Uint8Array(0) };
}

export const SwitchSidesRequest = {
  encode(message: SwitchSidesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid.length !== 0) {
      writer.uint32(10).bytes(message.uuid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwitchSidesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchSidesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwitchSidesRequest {
    return { uuid: isSet(object.uuid) ? bytesFromBase64(object.uuid) : new Uint8Array(0) };
  },

  toJSON(message: SwitchSidesRequest): unknown {
    const obj: any = {};
    if (message.uuid.length !== 0) {
      obj.uuid = base64FromBytes(message.uuid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwitchSidesRequest>, I>>(base?: I): SwitchSidesRequest {
    return SwitchSidesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwitchSidesRequest>, I>>(object: I): SwitchSidesRequest {
    const message = createBaseSwitchSidesRequest();
    message.uuid = object.uuid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSwitchSidesResponse(): SwitchSidesResponse {
  return { uuid: new Uint8Array(0), lr: undefined };
}

export const SwitchSidesResponse = {
  encode(message: SwitchSidesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid.length !== 0) {
      writer.uint32(10).bytes(message.uuid);
    }
    if (message.lr !== undefined) {
      LoginRequest.encode(message.lr, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwitchSidesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchSidesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lr = LoginRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwitchSidesResponse {
    return {
      uuid: isSet(object.uuid) ? bytesFromBase64(object.uuid) : new Uint8Array(0),
      lr: isSet(object.lr) ? LoginRequest.fromJSON(object.lr) : undefined,
    };
  },

  toJSON(message: SwitchSidesResponse): unknown {
    const obj: any = {};
    if (message.uuid.length !== 0) {
      obj.uuid = base64FromBytes(message.uuid);
    }
    if (message.lr !== undefined) {
      obj.lr = LoginRequest.toJSON(message.lr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwitchSidesResponse>, I>>(base?: I): SwitchSidesResponse {
    return SwitchSidesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwitchSidesResponse>, I>>(object: I): SwitchSidesResponse {
    const message = createBaseSwitchSidesResponse();
    message.uuid = object.uuid ?? new Uint8Array(0);
    message.lr = (object.lr !== undefined && object.lr !== null) ? LoginRequest.fromPartial(object.lr) : undefined;
    return message;
  },
};

function createBaseSwitchBack(): SwitchBack {
  return {};
}

export const SwitchBack = {
  encode(_: SwitchBack, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwitchBack {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchBack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SwitchBack {
    return {};
  },

  toJSON(_: SwitchBack): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SwitchBack>, I>>(base?: I): SwitchBack {
    return SwitchBack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwitchBack>, I>>(_: I): SwitchBack {
    const message = createBaseSwitchBack();
    return message;
  },
};

function createBasePluginRequest(): PluginRequest {
  return { id: "", content: new Uint8Array(0) };
}

export const PluginRequest = {
  encode(message: PluginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content.length !== 0) {
      writer.uint32(18).bytes(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PluginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
    };
  },

  toJSON(message: PluginRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginRequest>, I>>(base?: I): PluginRequest {
    return PluginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginRequest>, I>>(object: I): PluginRequest {
    const message = createBasePluginRequest();
    message.id = object.id ?? "";
    message.content = object.content ?? new Uint8Array(0);
    return message;
  },
};

function createBasePluginFailure(): PluginFailure {
  return { id: "", name: "", msg: "" };
}

export const PluginFailure = {
  encode(message: PluginFailure, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PluginFailure {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginFailure {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: PluginFailure): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginFailure>, I>>(base?: I): PluginFailure {
    return PluginFailure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginFailure>, I>>(object: I): PluginFailure {
    const message = createBasePluginFailure();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseWindowsSessions(): WindowsSessions {
  return { sessions: [], current_sid: 0 };
}

export const WindowsSessions = {
  encode(message: WindowsSessions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sessions) {
      WindowsSession.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.current_sid !== 0) {
      writer.uint32(16).uint32(message.current_sid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WindowsSessions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsSessions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessions.push(WindowsSession.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.current_sid = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsSessions {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => WindowsSession.fromJSON(e))
        : [],
      current_sid: isSet(object.current_sid) ? globalThis.Number(object.current_sid) : 0,
    };
  },

  toJSON(message: WindowsSessions): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => WindowsSession.toJSON(e));
    }
    if (message.current_sid !== 0) {
      obj.current_sid = Math.round(message.current_sid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowsSessions>, I>>(base?: I): WindowsSessions {
    return WindowsSessions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowsSessions>, I>>(object: I): WindowsSessions {
    const message = createBaseWindowsSessions();
    message.sessions = object.sessions?.map((e) => WindowsSession.fromPartial(e)) || [];
    message.current_sid = object.current_sid ?? 0;
    return message;
  },
};

function createBaseMessageQuery(): MessageQuery {
  return { switch_display: 0 };
}

export const MessageQuery = {
  encode(message: MessageQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.switch_display !== 0) {
      writer.uint32(8).int32(message.switch_display);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.switch_display = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageQuery {
    return { switch_display: isSet(object.switch_display) ? globalThis.Number(object.switch_display) : 0 };
  },

  toJSON(message: MessageQuery): unknown {
    const obj: any = {};
    if (message.switch_display !== 0) {
      obj.switch_display = Math.round(message.switch_display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageQuery>, I>>(base?: I): MessageQuery {
    return MessageQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageQuery>, I>>(object: I): MessageQuery {
    const message = createBaseMessageQuery();
    message.switch_display = object.switch_display ?? 0;
    return message;
  },
};

function createBaseMisc(): Misc {
  return {
    chat_message: undefined,
    switch_display: undefined,
    permission_info: undefined,
    option: undefined,
    audio_format: undefined,
    close_reason: undefined,
    refresh_video: undefined,
    video_received: undefined,
    back_notification: undefined,
    restart_remote_device: undefined,
    uac: undefined,
    foreground_window_elevated: undefined,
    stop_service: undefined,
    elevation_request: undefined,
    elevation_response: undefined,
    portable_service_running: undefined,
    switch_sides_request: undefined,
    switch_back: undefined,
    change_resolution: undefined,
    plugin_request: undefined,
    plugin_failure: undefined,
    full_speed_fps: undefined,
    auto_adjust_fps: undefined,
    client_record_status: undefined,
    capture_displays: undefined,
    refresh_video_display: undefined,
    toggle_virtual_display: undefined,
    toggle_privacy_mode: undefined,
    supported_encoding: undefined,
    selected_sid: undefined,
    change_display_resolution: undefined,
    message_query: undefined,
    follow_current_display: undefined,
  };
}

export const Misc = {
  encode(message: Misc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chat_message !== undefined) {
      ChatMessage.encode(message.chat_message, writer.uint32(34).fork()).ldelim();
    }
    if (message.switch_display !== undefined) {
      SwitchDisplay.encode(message.switch_display, writer.uint32(42).fork()).ldelim();
    }
    if (message.permission_info !== undefined) {
      PermissionInfo.encode(message.permission_info, writer.uint32(50).fork()).ldelim();
    }
    if (message.option !== undefined) {
      OptionMessage.encode(message.option, writer.uint32(58).fork()).ldelim();
    }
    if (message.audio_format !== undefined) {
      AudioFormat.encode(message.audio_format, writer.uint32(66).fork()).ldelim();
    }
    if (message.close_reason !== undefined) {
      writer.uint32(74).string(message.close_reason);
    }
    if (message.refresh_video !== undefined) {
      writer.uint32(80).bool(message.refresh_video);
    }
    if (message.video_received !== undefined) {
      writer.uint32(96).bool(message.video_received);
    }
    if (message.back_notification !== undefined) {
      BackNotification.encode(message.back_notification, writer.uint32(106).fork()).ldelim();
    }
    if (message.restart_remote_device !== undefined) {
      writer.uint32(112).bool(message.restart_remote_device);
    }
    if (message.uac !== undefined) {
      writer.uint32(120).bool(message.uac);
    }
    if (message.foreground_window_elevated !== undefined) {
      writer.uint32(128).bool(message.foreground_window_elevated);
    }
    if (message.stop_service !== undefined) {
      writer.uint32(136).bool(message.stop_service);
    }
    if (message.elevation_request !== undefined) {
      ElevationRequest.encode(message.elevation_request, writer.uint32(146).fork()).ldelim();
    }
    if (message.elevation_response !== undefined) {
      writer.uint32(154).string(message.elevation_response);
    }
    if (message.portable_service_running !== undefined) {
      writer.uint32(160).bool(message.portable_service_running);
    }
    if (message.switch_sides_request !== undefined) {
      SwitchSidesRequest.encode(message.switch_sides_request, writer.uint32(170).fork()).ldelim();
    }
    if (message.switch_back !== undefined) {
      SwitchBack.encode(message.switch_back, writer.uint32(178).fork()).ldelim();
    }
    if (message.change_resolution !== undefined) {
      Resolution.encode(message.change_resolution, writer.uint32(194).fork()).ldelim();
    }
    if (message.plugin_request !== undefined) {
      PluginRequest.encode(message.plugin_request, writer.uint32(202).fork()).ldelim();
    }
    if (message.plugin_failure !== undefined) {
      PluginFailure.encode(message.plugin_failure, writer.uint32(210).fork()).ldelim();
    }
    if (message.full_speed_fps !== undefined) {
      writer.uint32(216).uint32(message.full_speed_fps);
    }
    if (message.auto_adjust_fps !== undefined) {
      writer.uint32(224).uint32(message.auto_adjust_fps);
    }
    if (message.client_record_status !== undefined) {
      writer.uint32(232).bool(message.client_record_status);
    }
    if (message.capture_displays !== undefined) {
      CaptureDisplays.encode(message.capture_displays, writer.uint32(242).fork()).ldelim();
    }
    if (message.refresh_video_display !== undefined) {
      writer.uint32(248).int32(message.refresh_video_display);
    }
    if (message.toggle_virtual_display !== undefined) {
      ToggleVirtualDisplay.encode(message.toggle_virtual_display, writer.uint32(258).fork()).ldelim();
    }
    if (message.toggle_privacy_mode !== undefined) {
      TogglePrivacyMode.encode(message.toggle_privacy_mode, writer.uint32(266).fork()).ldelim();
    }
    if (message.supported_encoding !== undefined) {
      SupportedEncoding.encode(message.supported_encoding, writer.uint32(274).fork()).ldelim();
    }
    if (message.selected_sid !== undefined) {
      writer.uint32(280).uint32(message.selected_sid);
    }
    if (message.change_display_resolution !== undefined) {
      DisplayResolution.encode(message.change_display_resolution, writer.uint32(290).fork()).ldelim();
    }
    if (message.message_query !== undefined) {
      MessageQuery.encode(message.message_query, writer.uint32(298).fork()).ldelim();
    }
    if (message.follow_current_display !== undefined) {
      writer.uint32(304).int32(message.follow_current_display);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Misc {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMisc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chat_message = ChatMessage.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.switch_display = SwitchDisplay.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.permission_info = PermissionInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.option = OptionMessage.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.audio_format = AudioFormat.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.close_reason = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.refresh_video = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.video_received = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.back_notification = BackNotification.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.restart_remote_device = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.uac = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.foreground_window_elevated = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.stop_service = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.elevation_request = ElevationRequest.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.elevation_response = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.portable_service_running = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.switch_sides_request = SwitchSidesRequest.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.switch_back = SwitchBack.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.change_resolution = Resolution.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.plugin_request = PluginRequest.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.plugin_failure = PluginFailure.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.full_speed_fps = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.auto_adjust_fps = reader.uint32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.client_record_status = reader.bool();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.capture_displays = CaptureDisplays.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.refresh_video_display = reader.int32();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.toggle_virtual_display = ToggleVirtualDisplay.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.toggle_privacy_mode = TogglePrivacyMode.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.supported_encoding = SupportedEncoding.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.selected_sid = reader.uint32();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.change_display_resolution = DisplayResolution.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.message_query = MessageQuery.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.follow_current_display = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Misc {
    return {
      chat_message: isSet(object.chat_message) ? ChatMessage.fromJSON(object.chat_message) : undefined,
      switch_display: isSet(object.switch_display) ? SwitchDisplay.fromJSON(object.switch_display) : undefined,
      permission_info: isSet(object.permission_info) ? PermissionInfo.fromJSON(object.permission_info) : undefined,
      option: isSet(object.option) ? OptionMessage.fromJSON(object.option) : undefined,
      audio_format: isSet(object.audio_format) ? AudioFormat.fromJSON(object.audio_format) : undefined,
      close_reason: isSet(object.close_reason) ? globalThis.String(object.close_reason) : undefined,
      refresh_video: isSet(object.refresh_video) ? globalThis.Boolean(object.refresh_video) : undefined,
      video_received: isSet(object.video_received) ? globalThis.Boolean(object.video_received) : undefined,
      back_notification: isSet(object.back_notification)
        ? BackNotification.fromJSON(object.back_notification)
        : undefined,
      restart_remote_device: isSet(object.restart_remote_device)
        ? globalThis.Boolean(object.restart_remote_device)
        : undefined,
      uac: isSet(object.uac) ? globalThis.Boolean(object.uac) : undefined,
      foreground_window_elevated: isSet(object.foreground_window_elevated)
        ? globalThis.Boolean(object.foreground_window_elevated)
        : undefined,
      stop_service: isSet(object.stop_service) ? globalThis.Boolean(object.stop_service) : undefined,
      elevation_request: isSet(object.elevation_request)
        ? ElevationRequest.fromJSON(object.elevation_request)
        : undefined,
      elevation_response: isSet(object.elevation_response) ? globalThis.String(object.elevation_response) : undefined,
      portable_service_running: isSet(object.portable_service_running)
        ? globalThis.Boolean(object.portable_service_running)
        : undefined,
      switch_sides_request: isSet(object.switch_sides_request)
        ? SwitchSidesRequest.fromJSON(object.switch_sides_request)
        : undefined,
      switch_back: isSet(object.switch_back) ? SwitchBack.fromJSON(object.switch_back) : undefined,
      change_resolution: isSet(object.change_resolution) ? Resolution.fromJSON(object.change_resolution) : undefined,
      plugin_request: isSet(object.plugin_request) ? PluginRequest.fromJSON(object.plugin_request) : undefined,
      plugin_failure: isSet(object.plugin_failure) ? PluginFailure.fromJSON(object.plugin_failure) : undefined,
      full_speed_fps: isSet(object.full_speed_fps) ? globalThis.Number(object.full_speed_fps) : undefined,
      auto_adjust_fps: isSet(object.auto_adjust_fps) ? globalThis.Number(object.auto_adjust_fps) : undefined,
      client_record_status: isSet(object.client_record_status)
        ? globalThis.Boolean(object.client_record_status)
        : undefined,
      capture_displays: isSet(object.capture_displays) ? CaptureDisplays.fromJSON(object.capture_displays) : undefined,
      refresh_video_display: isSet(object.refresh_video_display)
        ? globalThis.Number(object.refresh_video_display)
        : undefined,
      toggle_virtual_display: isSet(object.toggle_virtual_display)
        ? ToggleVirtualDisplay.fromJSON(object.toggle_virtual_display)
        : undefined,
      toggle_privacy_mode: isSet(object.toggle_privacy_mode)
        ? TogglePrivacyMode.fromJSON(object.toggle_privacy_mode)
        : undefined,
      supported_encoding: isSet(object.supported_encoding)
        ? SupportedEncoding.fromJSON(object.supported_encoding)
        : undefined,
      selected_sid: isSet(object.selected_sid) ? globalThis.Number(object.selected_sid) : undefined,
      change_display_resolution: isSet(object.change_display_resolution)
        ? DisplayResolution.fromJSON(object.change_display_resolution)
        : undefined,
      message_query: isSet(object.message_query) ? MessageQuery.fromJSON(object.message_query) : undefined,
      follow_current_display: isSet(object.follow_current_display)
        ? globalThis.Number(object.follow_current_display)
        : undefined,
    };
  },

  toJSON(message: Misc): unknown {
    const obj: any = {};
    if (message.chat_message !== undefined) {
      obj.chat_message = ChatMessage.toJSON(message.chat_message);
    }
    if (message.switch_display !== undefined) {
      obj.switch_display = SwitchDisplay.toJSON(message.switch_display);
    }
    if (message.permission_info !== undefined) {
      obj.permission_info = PermissionInfo.toJSON(message.permission_info);
    }
    if (message.option !== undefined) {
      obj.option = OptionMessage.toJSON(message.option);
    }
    if (message.audio_format !== undefined) {
      obj.audio_format = AudioFormat.toJSON(message.audio_format);
    }
    if (message.close_reason !== undefined) {
      obj.close_reason = message.close_reason;
    }
    if (message.refresh_video !== undefined) {
      obj.refresh_video = message.refresh_video;
    }
    if (message.video_received !== undefined) {
      obj.video_received = message.video_received;
    }
    if (message.back_notification !== undefined) {
      obj.back_notification = BackNotification.toJSON(message.back_notification);
    }
    if (message.restart_remote_device !== undefined) {
      obj.restart_remote_device = message.restart_remote_device;
    }
    if (message.uac !== undefined) {
      obj.uac = message.uac;
    }
    if (message.foreground_window_elevated !== undefined) {
      obj.foreground_window_elevated = message.foreground_window_elevated;
    }
    if (message.stop_service !== undefined) {
      obj.stop_service = message.stop_service;
    }
    if (message.elevation_request !== undefined) {
      obj.elevation_request = ElevationRequest.toJSON(message.elevation_request);
    }
    if (message.elevation_response !== undefined) {
      obj.elevation_response = message.elevation_response;
    }
    if (message.portable_service_running !== undefined) {
      obj.portable_service_running = message.portable_service_running;
    }
    if (message.switch_sides_request !== undefined) {
      obj.switch_sides_request = SwitchSidesRequest.toJSON(message.switch_sides_request);
    }
    if (message.switch_back !== undefined) {
      obj.switch_back = SwitchBack.toJSON(message.switch_back);
    }
    if (message.change_resolution !== undefined) {
      obj.change_resolution = Resolution.toJSON(message.change_resolution);
    }
    if (message.plugin_request !== undefined) {
      obj.plugin_request = PluginRequest.toJSON(message.plugin_request);
    }
    if (message.plugin_failure !== undefined) {
      obj.plugin_failure = PluginFailure.toJSON(message.plugin_failure);
    }
    if (message.full_speed_fps !== undefined) {
      obj.full_speed_fps = Math.round(message.full_speed_fps);
    }
    if (message.auto_adjust_fps !== undefined) {
      obj.auto_adjust_fps = Math.round(message.auto_adjust_fps);
    }
    if (message.client_record_status !== undefined) {
      obj.client_record_status = message.client_record_status;
    }
    if (message.capture_displays !== undefined) {
      obj.capture_displays = CaptureDisplays.toJSON(message.capture_displays);
    }
    if (message.refresh_video_display !== undefined) {
      obj.refresh_video_display = Math.round(message.refresh_video_display);
    }
    if (message.toggle_virtual_display !== undefined) {
      obj.toggle_virtual_display = ToggleVirtualDisplay.toJSON(message.toggle_virtual_display);
    }
    if (message.toggle_privacy_mode !== undefined) {
      obj.toggle_privacy_mode = TogglePrivacyMode.toJSON(message.toggle_privacy_mode);
    }
    if (message.supported_encoding !== undefined) {
      obj.supported_encoding = SupportedEncoding.toJSON(message.supported_encoding);
    }
    if (message.selected_sid !== undefined) {
      obj.selected_sid = Math.round(message.selected_sid);
    }
    if (message.change_display_resolution !== undefined) {
      obj.change_display_resolution = DisplayResolution.toJSON(message.change_display_resolution);
    }
    if (message.message_query !== undefined) {
      obj.message_query = MessageQuery.toJSON(message.message_query);
    }
    if (message.follow_current_display !== undefined) {
      obj.follow_current_display = Math.round(message.follow_current_display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Misc>, I>>(base?: I): Misc {
    return Misc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Misc>, I>>(object: I): Misc {
    const message = createBaseMisc();
    message.chat_message = (object.chat_message !== undefined && object.chat_message !== null)
      ? ChatMessage.fromPartial(object.chat_message)
      : undefined;
    message.switch_display = (object.switch_display !== undefined && object.switch_display !== null)
      ? SwitchDisplay.fromPartial(object.switch_display)
      : undefined;
    message.permission_info = (object.permission_info !== undefined && object.permission_info !== null)
      ? PermissionInfo.fromPartial(object.permission_info)
      : undefined;
    message.option = (object.option !== undefined && object.option !== null)
      ? OptionMessage.fromPartial(object.option)
      : undefined;
    message.audio_format = (object.audio_format !== undefined && object.audio_format !== null)
      ? AudioFormat.fromPartial(object.audio_format)
      : undefined;
    message.close_reason = object.close_reason ?? undefined;
    message.refresh_video = object.refresh_video ?? undefined;
    message.video_received = object.video_received ?? undefined;
    message.back_notification = (object.back_notification !== undefined && object.back_notification !== null)
      ? BackNotification.fromPartial(object.back_notification)
      : undefined;
    message.restart_remote_device = object.restart_remote_device ?? undefined;
    message.uac = object.uac ?? undefined;
    message.foreground_window_elevated = object.foreground_window_elevated ?? undefined;
    message.stop_service = object.stop_service ?? undefined;
    message.elevation_request = (object.elevation_request !== undefined && object.elevation_request !== null)
      ? ElevationRequest.fromPartial(object.elevation_request)
      : undefined;
    message.elevation_response = object.elevation_response ?? undefined;
    message.portable_service_running = object.portable_service_running ?? undefined;
    message.switch_sides_request = (object.switch_sides_request !== undefined && object.switch_sides_request !== null)
      ? SwitchSidesRequest.fromPartial(object.switch_sides_request)
      : undefined;
    message.switch_back = (object.switch_back !== undefined && object.switch_back !== null)
      ? SwitchBack.fromPartial(object.switch_back)
      : undefined;
    message.change_resolution = (object.change_resolution !== undefined && object.change_resolution !== null)
      ? Resolution.fromPartial(object.change_resolution)
      : undefined;
    message.plugin_request = (object.plugin_request !== undefined && object.plugin_request !== null)
      ? PluginRequest.fromPartial(object.plugin_request)
      : undefined;
    message.plugin_failure = (object.plugin_failure !== undefined && object.plugin_failure !== null)
      ? PluginFailure.fromPartial(object.plugin_failure)
      : undefined;
    message.full_speed_fps = object.full_speed_fps ?? undefined;
    message.auto_adjust_fps = object.auto_adjust_fps ?? undefined;
    message.client_record_status = object.client_record_status ?? undefined;
    message.capture_displays = (object.capture_displays !== undefined && object.capture_displays !== null)
      ? CaptureDisplays.fromPartial(object.capture_displays)
      : undefined;
    message.refresh_video_display = object.refresh_video_display ?? undefined;
    message.toggle_virtual_display =
      (object.toggle_virtual_display !== undefined && object.toggle_virtual_display !== null)
        ? ToggleVirtualDisplay.fromPartial(object.toggle_virtual_display)
        : undefined;
    message.toggle_privacy_mode = (object.toggle_privacy_mode !== undefined && object.toggle_privacy_mode !== null)
      ? TogglePrivacyMode.fromPartial(object.toggle_privacy_mode)
      : undefined;
    message.supported_encoding = (object.supported_encoding !== undefined && object.supported_encoding !== null)
      ? SupportedEncoding.fromPartial(object.supported_encoding)
      : undefined;
    message.selected_sid = object.selected_sid ?? undefined;
    message.change_display_resolution =
      (object.change_display_resolution !== undefined && object.change_display_resolution !== null)
        ? DisplayResolution.fromPartial(object.change_display_resolution)
        : undefined;
    message.message_query = (object.message_query !== undefined && object.message_query !== null)
      ? MessageQuery.fromPartial(object.message_query)
      : undefined;
    message.follow_current_display = object.follow_current_display ?? undefined;
    return message;
  },
};

function createBaseVoiceCallRequest(): VoiceCallRequest {
  return { req_timestamp: 0, is_connect: false };
}

export const VoiceCallRequest = {
  encode(message: VoiceCallRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.req_timestamp !== 0) {
      writer.uint32(8).int64(message.req_timestamp);
    }
    if (message.is_connect !== false) {
      writer.uint32(16).bool(message.is_connect);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceCallRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceCallRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.req_timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.is_connect = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceCallRequest {
    return {
      req_timestamp: isSet(object.req_timestamp) ? globalThis.Number(object.req_timestamp) : 0,
      is_connect: isSet(object.is_connect) ? globalThis.Boolean(object.is_connect) : false,
    };
  },

  toJSON(message: VoiceCallRequest): unknown {
    const obj: any = {};
    if (message.req_timestamp !== 0) {
      obj.req_timestamp = Math.round(message.req_timestamp);
    }
    if (message.is_connect !== false) {
      obj.is_connect = message.is_connect;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceCallRequest>, I>>(base?: I): VoiceCallRequest {
    return VoiceCallRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceCallRequest>, I>>(object: I): VoiceCallRequest {
    const message = createBaseVoiceCallRequest();
    message.req_timestamp = object.req_timestamp ?? 0;
    message.is_connect = object.is_connect ?? false;
    return message;
  },
};

function createBaseVoiceCallResponse(): VoiceCallResponse {
  return { accepted: false, req_timestamp: 0, ack_timestamp: 0 };
}

export const VoiceCallResponse = {
  encode(message: VoiceCallResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accepted !== false) {
      writer.uint32(8).bool(message.accepted);
    }
    if (message.req_timestamp !== 0) {
      writer.uint32(16).int64(message.req_timestamp);
    }
    if (message.ack_timestamp !== 0) {
      writer.uint32(24).int64(message.ack_timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceCallResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceCallResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.req_timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ack_timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceCallResponse {
    return {
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
      req_timestamp: isSet(object.req_timestamp) ? globalThis.Number(object.req_timestamp) : 0,
      ack_timestamp: isSet(object.ack_timestamp) ? globalThis.Number(object.ack_timestamp) : 0,
    };
  },

  toJSON(message: VoiceCallResponse): unknown {
    const obj: any = {};
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    if (message.req_timestamp !== 0) {
      obj.req_timestamp = Math.round(message.req_timestamp);
    }
    if (message.ack_timestamp !== 0) {
      obj.ack_timestamp = Math.round(message.ack_timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceCallResponse>, I>>(base?: I): VoiceCallResponse {
    return VoiceCallResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceCallResponse>, I>>(object: I): VoiceCallResponse {
    const message = createBaseVoiceCallResponse();
    message.accepted = object.accepted ?? false;
    message.req_timestamp = object.req_timestamp ?? 0;
    message.ack_timestamp = object.ack_timestamp ?? 0;
    return message;
  },
};

function createBaseScreenshotRequest(): ScreenshotRequest {
  return { display: 0, sid: "" };
}

export const ScreenshotRequest = {
  encode(message: ScreenshotRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.display !== 0) {
      writer.uint32(8).int32(message.display);
    }
    if (message.sid !== "") {
      writer.uint32(18).string(message.sid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScreenshotRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.display = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotRequest {
    return {
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
      sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
    };
  },

  toJSON(message: ScreenshotRequest): unknown {
    const obj: any = {};
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    if (message.sid !== "") {
      obj.sid = message.sid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotRequest>, I>>(base?: I): ScreenshotRequest {
    return ScreenshotRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotRequest>, I>>(object: I): ScreenshotRequest {
    const message = createBaseScreenshotRequest();
    message.display = object.display ?? 0;
    message.sid = object.sid ?? "";
    return message;
  },
};

function createBaseScreenshotResponse(): ScreenshotResponse {
  return { sid: "", msg: "", data: new Uint8Array(0) };
}

export const ScreenshotResponse = {
  encode(message: ScreenshotResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sid !== "") {
      writer.uint32(10).string(message.sid);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScreenshotResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotResponse {
    return {
      sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: ScreenshotResponse): unknown {
    const obj: any = {};
    if (message.sid !== "") {
      obj.sid = message.sid;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotResponse>, I>>(base?: I): ScreenshotResponse {
    return ScreenshotResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotResponse>, I>>(object: I): ScreenshotResponse {
    const message = createBaseScreenshotResponse();
    message.sid = object.sid ?? "";
    message.msg = object.msg ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    signed_id: undefined,
    public_key: undefined,
    test_delay: undefined,
    video_frame: undefined,
    login_request: undefined,
    login_response: undefined,
    hash: undefined,
    mouse_event: undefined,
    audio_frame: undefined,
    cursor_data: undefined,
    cursor_position: undefined,
    cursor_id: undefined,
    key_event: undefined,
    clipboard: undefined,
    file_action: undefined,
    file_response: undefined,
    misc: undefined,
    cliprdr: undefined,
    message_box: undefined,
    switch_sides_response: undefined,
    voice_call_request: undefined,
    voice_call_response: undefined,
    peer_info: undefined,
    pointer_device_event: undefined,
    auth_2fa: undefined,
    multi_clipboards: undefined,
    screenshot_request: undefined,
    screenshot_response: undefined,
  };
}

export const Message = {
  encode(message: Message, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signed_id !== undefined) {
      SignedId.encode(message.signed_id, writer.uint32(26).fork()).ldelim();
    }
    if (message.public_key !== undefined) {
      PublicKey.encode(message.public_key, writer.uint32(34).fork()).ldelim();
    }
    if (message.test_delay !== undefined) {
      TestDelay.encode(message.test_delay, writer.uint32(42).fork()).ldelim();
    }
    if (message.video_frame !== undefined) {
      VideoFrame.encode(message.video_frame, writer.uint32(50).fork()).ldelim();
    }
    if (message.login_request !== undefined) {
      LoginRequest.encode(message.login_request, writer.uint32(58).fork()).ldelim();
    }
    if (message.login_response !== undefined) {
      LoginResponse.encode(message.login_response, writer.uint32(66).fork()).ldelim();
    }
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(74).fork()).ldelim();
    }
    if (message.mouse_event !== undefined) {
      MouseEvent.encode(message.mouse_event, writer.uint32(82).fork()).ldelim();
    }
    if (message.audio_frame !== undefined) {
      AudioFrame.encode(message.audio_frame, writer.uint32(90).fork()).ldelim();
    }
    if (message.cursor_data !== undefined) {
      CursorData.encode(message.cursor_data, writer.uint32(98).fork()).ldelim();
    }
    if (message.cursor_position !== undefined) {
      CursorPosition.encode(message.cursor_position, writer.uint32(106).fork()).ldelim();
    }
    if (message.cursor_id !== undefined) {
      writer.uint32(112).uint64(message.cursor_id);
    }
    if (message.key_event !== undefined) {
      KeyEvent.encode(message.key_event, writer.uint32(122).fork()).ldelim();
    }
    if (message.clipboard !== undefined) {
      Clipboard.encode(message.clipboard, writer.uint32(130).fork()).ldelim();
    }
    if (message.file_action !== undefined) {
      FileAction.encode(message.file_action, writer.uint32(138).fork()).ldelim();
    }
    if (message.file_response !== undefined) {
      FileResponse.encode(message.file_response, writer.uint32(146).fork()).ldelim();
    }
    if (message.misc !== undefined) {
      Misc.encode(message.misc, writer.uint32(154).fork()).ldelim();
    }
    if (message.cliprdr !== undefined) {
      Cliprdr.encode(message.cliprdr, writer.uint32(162).fork()).ldelim();
    }
    if (message.message_box !== undefined) {
      MessageBox.encode(message.message_box, writer.uint32(170).fork()).ldelim();
    }
    if (message.switch_sides_response !== undefined) {
      SwitchSidesResponse.encode(message.switch_sides_response, writer.uint32(178).fork()).ldelim();
    }
    if (message.voice_call_request !== undefined) {
      VoiceCallRequest.encode(message.voice_call_request, writer.uint32(186).fork()).ldelim();
    }
    if (message.voice_call_response !== undefined) {
      VoiceCallResponse.encode(message.voice_call_response, writer.uint32(194).fork()).ldelim();
    }
    if (message.peer_info !== undefined) {
      PeerInfo.encode(message.peer_info, writer.uint32(202).fork()).ldelim();
    }
    if (message.pointer_device_event !== undefined) {
      PointerDeviceEvent.encode(message.pointer_device_event, writer.uint32(210).fork()).ldelim();
    }
    if (message.auth_2fa !== undefined) {
      Auth2FA.encode(message.auth_2fa, writer.uint32(218).fork()).ldelim();
    }
    if (message.multi_clipboards !== undefined) {
      MultiClipboards.encode(message.multi_clipboards, writer.uint32(226).fork()).ldelim();
    }
    if (message.screenshot_request !== undefined) {
      ScreenshotRequest.encode(message.screenshot_request, writer.uint32(234).fork()).ldelim();
    }
    if (message.screenshot_response !== undefined) {
      ScreenshotResponse.encode(message.screenshot_response, writer.uint32(242).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Message {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signed_id = SignedId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.public_key = PublicKey.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.test_delay = TestDelay.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.video_frame = VideoFrame.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.login_request = LoginRequest.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.login_response = LoginResponse.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mouse_event = MouseEvent.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.audio_frame = AudioFrame.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.cursor_data = CursorData.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.cursor_position = CursorPosition.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.cursor_id = longToNumber(reader.uint64() as Long);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.key_event = KeyEvent.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.clipboard = Clipboard.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.file_action = FileAction.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.file_response = FileResponse.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.misc = Misc.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.cliprdr = Cliprdr.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.message_box = MessageBox.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.switch_sides_response = SwitchSidesResponse.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.voice_call_request = VoiceCallRequest.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.voice_call_response = VoiceCallResponse.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.peer_info = PeerInfo.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.pointer_device_event = PointerDeviceEvent.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.auth_2fa = Auth2FA.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.multi_clipboards = MultiClipboards.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.screenshot_request = ScreenshotRequest.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.screenshot_response = ScreenshotResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      signed_id: isSet(object.signed_id) ? SignedId.fromJSON(object.signed_id) : undefined,
      public_key: isSet(object.public_key) ? PublicKey.fromJSON(object.public_key) : undefined,
      test_delay: isSet(object.test_delay) ? TestDelay.fromJSON(object.test_delay) : undefined,
      video_frame: isSet(object.video_frame) ? VideoFrame.fromJSON(object.video_frame) : undefined,
      login_request: isSet(object.login_request) ? LoginRequest.fromJSON(object.login_request) : undefined,
      login_response: isSet(object.login_response) ? LoginResponse.fromJSON(object.login_response) : undefined,
      hash: isSet(object.hash) ? Hash.fromJSON(object.hash) : undefined,
      mouse_event: isSet(object.mouse_event) ? MouseEvent.fromJSON(object.mouse_event) : undefined,
      audio_frame: isSet(object.audio_frame) ? AudioFrame.fromJSON(object.audio_frame) : undefined,
      cursor_data: isSet(object.cursor_data) ? CursorData.fromJSON(object.cursor_data) : undefined,
      cursor_position: isSet(object.cursor_position) ? CursorPosition.fromJSON(object.cursor_position) : undefined,
      cursor_id: isSet(object.cursor_id) ? globalThis.Number(object.cursor_id) : undefined,
      key_event: isSet(object.key_event) ? KeyEvent.fromJSON(object.key_event) : undefined,
      clipboard: isSet(object.clipboard) ? Clipboard.fromJSON(object.clipboard) : undefined,
      file_action: isSet(object.file_action) ? FileAction.fromJSON(object.file_action) : undefined,
      file_response: isSet(object.file_response) ? FileResponse.fromJSON(object.file_response) : undefined,
      misc: isSet(object.misc) ? Misc.fromJSON(object.misc) : undefined,
      cliprdr: isSet(object.cliprdr) ? Cliprdr.fromJSON(object.cliprdr) : undefined,
      message_box: isSet(object.message_box) ? MessageBox.fromJSON(object.message_box) : undefined,
      switch_sides_response: isSet(object.switch_sides_response)
        ? SwitchSidesResponse.fromJSON(object.switch_sides_response)
        : undefined,
      voice_call_request: isSet(object.voice_call_request)
        ? VoiceCallRequest.fromJSON(object.voice_call_request)
        : undefined,
      voice_call_response: isSet(object.voice_call_response)
        ? VoiceCallResponse.fromJSON(object.voice_call_response)
        : undefined,
      peer_info: isSet(object.peer_info) ? PeerInfo.fromJSON(object.peer_info) : undefined,
      pointer_device_event: isSet(object.pointer_device_event)
        ? PointerDeviceEvent.fromJSON(object.pointer_device_event)
        : undefined,
      auth_2fa: isSet(object.auth_2fa) ? Auth2FA.fromJSON(object.auth_2fa) : undefined,
      multi_clipboards: isSet(object.multi_clipboards) ? MultiClipboards.fromJSON(object.multi_clipboards) : undefined,
      screenshot_request: isSet(object.screenshot_request)
        ? ScreenshotRequest.fromJSON(object.screenshot_request)
        : undefined,
      screenshot_response: isSet(object.screenshot_response)
        ? ScreenshotResponse.fromJSON(object.screenshot_response)
        : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.signed_id !== undefined) {
      obj.signed_id = SignedId.toJSON(message.signed_id);
    }
    if (message.public_key !== undefined) {
      obj.public_key = PublicKey.toJSON(message.public_key);
    }
    if (message.test_delay !== undefined) {
      obj.test_delay = TestDelay.toJSON(message.test_delay);
    }
    if (message.video_frame !== undefined) {
      obj.video_frame = VideoFrame.toJSON(message.video_frame);
    }
    if (message.login_request !== undefined) {
      obj.login_request = LoginRequest.toJSON(message.login_request);
    }
    if (message.login_response !== undefined) {
      obj.login_response = LoginResponse.toJSON(message.login_response);
    }
    if (message.hash !== undefined) {
      obj.hash = Hash.toJSON(message.hash);
    }
    if (message.mouse_event !== undefined) {
      obj.mouse_event = MouseEvent.toJSON(message.mouse_event);
    }
    if (message.audio_frame !== undefined) {
      obj.audio_frame = AudioFrame.toJSON(message.audio_frame);
    }
    if (message.cursor_data !== undefined) {
      obj.cursor_data = CursorData.toJSON(message.cursor_data);
    }
    if (message.cursor_position !== undefined) {
      obj.cursor_position = CursorPosition.toJSON(message.cursor_position);
    }
    if (message.cursor_id !== undefined) {
      obj.cursor_id = Math.round(message.cursor_id);
    }
    if (message.key_event !== undefined) {
      obj.key_event = KeyEvent.toJSON(message.key_event);
    }
    if (message.clipboard !== undefined) {
      obj.clipboard = Clipboard.toJSON(message.clipboard);
    }
    if (message.file_action !== undefined) {
      obj.file_action = FileAction.toJSON(message.file_action);
    }
    if (message.file_response !== undefined) {
      obj.file_response = FileResponse.toJSON(message.file_response);
    }
    if (message.misc !== undefined) {
      obj.misc = Misc.toJSON(message.misc);
    }
    if (message.cliprdr !== undefined) {
      obj.cliprdr = Cliprdr.toJSON(message.cliprdr);
    }
    if (message.message_box !== undefined) {
      obj.message_box = MessageBox.toJSON(message.message_box);
    }
    if (message.switch_sides_response !== undefined) {
      obj.switch_sides_response = SwitchSidesResponse.toJSON(message.switch_sides_response);
    }
    if (message.voice_call_request !== undefined) {
      obj.voice_call_request = VoiceCallRequest.toJSON(message.voice_call_request);
    }
    if (message.voice_call_response !== undefined) {
      obj.voice_call_response = VoiceCallResponse.toJSON(message.voice_call_response);
    }
    if (message.peer_info !== undefined) {
      obj.peer_info = PeerInfo.toJSON(message.peer_info);
    }
    if (message.pointer_device_event !== undefined) {
      obj.pointer_device_event = PointerDeviceEvent.toJSON(message.pointer_device_event);
    }
    if (message.auth_2fa !== undefined) {
      obj.auth_2fa = Auth2FA.toJSON(message.auth_2fa);
    }
    if (message.multi_clipboards !== undefined) {
      obj.multi_clipboards = MultiClipboards.toJSON(message.multi_clipboards);
    }
    if (message.screenshot_request !== undefined) {
      obj.screenshot_request = ScreenshotRequest.toJSON(message.screenshot_request);
    }
    if (message.screenshot_response !== undefined) {
      obj.screenshot_response = ScreenshotResponse.toJSON(message.screenshot_response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.signed_id = (object.signed_id !== undefined && object.signed_id !== null)
      ? SignedId.fromPartial(object.signed_id)
      : undefined;
    message.public_key = (object.public_key !== undefined && object.public_key !== null)
      ? PublicKey.fromPartial(object.public_key)
      : undefined;
    message.test_delay = (object.test_delay !== undefined && object.test_delay !== null)
      ? TestDelay.fromPartial(object.test_delay)
      : undefined;
    message.video_frame = (object.video_frame !== undefined && object.video_frame !== null)
      ? VideoFrame.fromPartial(object.video_frame)
      : undefined;
    message.login_request = (object.login_request !== undefined && object.login_request !== null)
      ? LoginRequest.fromPartial(object.login_request)
      : undefined;
    message.login_response = (object.login_response !== undefined && object.login_response !== null)
      ? LoginResponse.fromPartial(object.login_response)
      : undefined;
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.mouse_event = (object.mouse_event !== undefined && object.mouse_event !== null)
      ? MouseEvent.fromPartial(object.mouse_event)
      : undefined;
    message.audio_frame = (object.audio_frame !== undefined && object.audio_frame !== null)
      ? AudioFrame.fromPartial(object.audio_frame)
      : undefined;
    message.cursor_data = (object.cursor_data !== undefined && object.cursor_data !== null)
      ? CursorData.fromPartial(object.cursor_data)
      : undefined;
    message.cursor_position = (object.cursor_position !== undefined && object.cursor_position !== null)
      ? CursorPosition.fromPartial(object.cursor_position)
      : undefined;
    message.cursor_id = object.cursor_id ?? undefined;
    message.key_event = (object.key_event !== undefined && object.key_event !== null)
      ? KeyEvent.fromPartial(object.key_event)
      : undefined;
    message.clipboard = (object.clipboard !== undefined && object.clipboard !== null)
      ? Clipboard.fromPartial(object.clipboard)
      : undefined;
    message.file_action = (object.file_action !== undefined && object.file_action !== null)
      ? FileAction.fromPartial(object.file_action)
      : undefined;
    message.file_response = (object.file_response !== undefined && object.file_response !== null)
      ? FileResponse.fromPartial(object.file_response)
      : undefined;
    message.misc = (object.misc !== undefined && object.misc !== null) ? Misc.fromPartial(object.misc) : undefined;
    message.cliprdr = (object.cliprdr !== undefined && object.cliprdr !== null)
      ? Cliprdr.fromPartial(object.cliprdr)
      : undefined;
    message.message_box = (object.message_box !== undefined && object.message_box !== null)
      ? MessageBox.fromPartial(object.message_box)
      : undefined;
    message.switch_sides_response =
      (object.switch_sides_response !== undefined && object.switch_sides_response !== null)
        ? SwitchSidesResponse.fromPartial(object.switch_sides_response)
        : undefined;
    message.voice_call_request = (object.voice_call_request !== undefined && object.voice_call_request !== null)
      ? VoiceCallRequest.fromPartial(object.voice_call_request)
      : undefined;
    message.voice_call_response = (object.voice_call_response !== undefined && object.voice_call_response !== null)
      ? VoiceCallResponse.fromPartial(object.voice_call_response)
      : undefined;
    message.peer_info = (object.peer_info !== undefined && object.peer_info !== null)
      ? PeerInfo.fromPartial(object.peer_info)
      : undefined;
    message.pointer_device_event = (object.pointer_device_event !== undefined && object.pointer_device_event !== null)
      ? PointerDeviceEvent.fromPartial(object.pointer_device_event)
      : undefined;
    message.auth_2fa = (object.auth_2fa !== undefined && object.auth_2fa !== null)
      ? Auth2FA.fromPartial(object.auth_2fa)
      : undefined;
    message.multi_clipboards = (object.multi_clipboards !== undefined && object.multi_clipboards !== null)
      ? MultiClipboards.fromPartial(object.multi_clipboards)
      : undefined;
    message.screenshot_request = (object.screenshot_request !== undefined && object.screenshot_request !== null)
      ? ScreenshotRequest.fromPartial(object.screenshot_request)
      : undefined;
    message.screenshot_response = (object.screenshot_response !== undefined && object.screenshot_response !== null)
      ? ScreenshotResponse.fromPartial(object.screenshot_response)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
